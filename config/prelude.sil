// -*- tab-width:2 ; indent-tabs-mode:nil -*-

domain VCTOption[T] {
  function VCTNone(): VCTOption[T]
  function VCTSome(t: T): VCTOption[T]
  function getVCTOption(o:VCTOption[T]) : T
    
  axiom not_equal_vct {
    forall x: T :: VCTNone() != VCTSome(x)
  }
  
  axiom get_axiom_vct {
    forall x: T :: getVCTOption(VCTSome(x)) == x
  }
}

domain VCTFloat {
    function zero() : VCTFloat
    function ffromint(i:Int) : VCTFloat
    function float(ref:Ref): VCTFloat
    function fsum(xs: Seq[VCTFloat]): VCTFloat
    function fsumrange(xs: Seq[VCTFloat],lo:Int,hi:Int): VCTFloat
    function fadd(f1 : VCTFloat,f2:VCTFloat):VCTFloat
    function fcount(bs: Seq[Bool]):Int
    function fcountrange(bs: Seq[Bool],lo:Int,hi:Int):Int
    
    axiom count_range_empty {
      forall xs : Seq[Bool],i:Int :: fcountrange(xs,i,i)==0
    }
    
    axiom count_range_single {
      forall xs : Seq[Bool],i:Int :: fcountrange(xs,i,i+1)==(xs[i]?1:0)
    }
    axiom count_range_extend_r {
      forall xs : Seq[Bool],i:Int,j:Int :: fcountrange(xs,i,j+1)==fcountrange(xs,i,j)+(xs[j]?1:0)
    }

    axiom count_empty {
      fcount(Seq[Bool]())==0
    }

    axiom count_single {
      forall b:Bool :: fcount(Seq(b))==(b?1:0)
    }
    
    axiom count_concat {
      forall xs : Seq[Bool], ys: Seq[Bool] :: { fcount(xs++ys) } fcount(xs++ys) == fcount(xs) + fcount(ys)
    }
    
    axiom commutative_add {
        forall f1 : VCTFloat, f2 : VCTFloat :: fadd(f1,f2)==fadd(f2,f1)
    }
    
    axiom zero_sum {
        fsum(Seq[VCTFloat]())==zero()
    }

    axiom zero_sum_r {
        forall xs : Seq[VCTFloat], i:Int :: fsumrange(xs,i,i) == zero()
    }

    axiom zero_int {
        ffromint(0)==zero()
    }
    
    axiom zero_add {
      forall f1 : VCTFloat :: fadd(f1,zero()) == f1
    }
    
    axiom single_sum {
      forall xs : Seq[VCTFloat], i:Int :: (0 <= i && i < |xs|) ==> (fsum(xs[i..i+1]) == xs[i])
    }
    
    axiom single_sum_2 {
      forall f : VCTFloat :: fsum(Seq(f)) == f
    }
    
    axiom append_sum {
      forall xs : Seq[VCTFloat], ys : Seq[VCTFloat] :: fsum(xs++ys) == fadd(fsum(xs),fsum(ys))
    }
    
    axiom extend_sum_r {
      forall xs : Seq[VCTFloat], i:Int, j:Int ::
        fsumrange(xs,i,j+1) == fadd(fsumrange(xs,i,j),xs[j])
    }
    
}

