// -*- tab-width:2 ; indent-tabs-mode:nil -*-
//:: cases demo3a-func
//:: tools silicon
//:: verdict Fail

class ArraySum {
    int sum;

    requires xs != null;
    requires 0 <= i && i <= xs.length;
    requires (\forall* int j; 0 <= j && j < xs.length; Perm(xs[j], read));
    pure int sumArray(int[] xs, int i) =
      (i == xs.length) ? 0 : xs[i] + sumArray(xs, i + 1);

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    requires xs.length == ys.length;
    requires 0 <= i && i <= xs.length;
    requires (\forall int j = 0 .. xs.length; xs[j] == ys[j]);
    ensures sumArray(xs, i) == sumArray(ys, i);
    void lemmaSumArrEq(int[] xs, int[] ys, int i) {
        if (i < xs.length) {
            lemmaSumArrEq(xs, ys, i + 1) with { P = P \ 2; };
        } else {
            // Vacuously true
        }
    }

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context (\forall int j = 0 .. xs.length; xs[j] == 0);
    requires 0 <= i && i <= xs.length;
    ensures sumArray(xs, i) == 0;
    void lemmaSumInit(int[] xs, int i) {
        if (i < xs.length) {
            lemmaSumInit(xs, i + 1) with { P = P\2; };
        } else {
            assert sumArray(xs, i) == 0;
        }
    }

    given frac P;
    context_everywhere P < write;
    context_everywhere xs != null;
    context_everywhere Perm(xs[*], P);
    ensures \result != null ** Perm(\result[*], write) ** \result.length == xs.length;
    ensures (\forall int i = 0 .. \result.length; \result[i] == xs[i]);
    int[] copy(int[] xs) {
        int[] res = new int[xs.length];

        loop_invariant 0 <= i && i <= xs.length;
        loop_invariant Perm(res[*], write) ** res.length == xs.length;
        loop_invariant (\forall int j = 0 .. i; res[j] == xs[j]);
        for (int i = 0; i < xs.length; i++) {
            res[i] = xs[i];
        }

        return res;
    }

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context (\forall int j = 0 .. xs.length; xs[j] == ys[j]);
    requires 0 <= i && i <= xs.length;
    requires sumArray(xs, i) == total;
    ensures sumArray(ys, i) == total;
    void lemmaSumCopy(int[] xs, int[] ys, int total, int i) {
        if (i == xs.length) {
            assert total == 0;
        } else {
            lemmaSumCopy(xs, ys, total - xs[i], i + 1) with { P = P\2; };
        }
    }

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context 0 <= i && i < xs.length;
    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
    requires sumArray(xs, 0) == oldTotal;
    ensures sumArray(ys, 0) == (oldTotal - xs[i] + ys[i]);
    void lemmaSumUpdate(int[] xs, int[] ys, int oldTotal, int i) {
        lemmaSumUpdateBefore(xs, ys, 0, oldTotal, i, xs[i], ys[i]) with { P = P \ 2; };
    }

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context 0 <= b && b <= xs.length;
    context 0 <= i && i < xs.length;
    context b <= i;
    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
    context xs[i] == oldVal;
    context ys[i] == newVal;
    requires sumArray(xs, b) == oldTotal;
    ensures sumArray(ys, b) == (oldTotal - oldVal + newVal);
    void lemmaSumUpdateBefore(int[] xs, int[] ys, int b, int oldTotal, int i, int oldVal, int newVal) {
        if (b < i) {
            lemmaSumUpdateBefore(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
        } else {
            lemmaSumUpdateAfter(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
        }
    }

    given frac P;
    context P < write;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context 0 <= b && b <= xs.length;
    context 0 <= i && i < xs.length;
    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
    context xs[i] == oldVal;
    context ys[i] == newVal;
    requires i < b;
    requires sumArray(xs, b) == oldTotal;
    ensures sumArray(ys, b) == oldTotal;
    void lemmaSumUpdateAfter(int[] xs, int[] ys, int b, int oldTotal, int i, int oldVal, int newVal) {
        if (b < xs.length) {
            lemmaSumUpdateAfter(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
            assert sumArray(ys, b) == oldTotal;
        } else {
            // Not necessary, but:
            assert oldTotal == 0;
            assert sumArray(ys, b) == 0;
            // Therefore, postcondition holds
        }
        assert sumArray(ys, b) == oldTotal;
    }

    context_everywhere A != null;
    context (\forall* int i; 0 <= i && i < A.length; Perm(A[i], 1\2));
    context Perm(this.sum, write);
    void sum(int[] A) {
        inhale false;
        int[] contrib = new int[A.length];
        sum = 0;
        lemmaSumInit(contrib, 0) with { P = 1\2; };
        assert sum == sumArray(contrib, 0);

        invariant inv(Perm(this.sum, write)
            ** contrib != null ** contrib.length == A.length
            ** (\forall* int i; 0 <= i && i < contrib.length; Perm(contrib[i], 1\2))
            ** sum == sumArray(contrib, 0)
        ) {
            par (int tid = 0 .. A.length)
            context contrib != null ** contrib.length == A.length;
            context Perm(A[tid], 1\4) ** Perm(contrib[tid], 1\2);
            requires contrib[tid] == 0;
            ensures contrib[tid] == A[tid];
            {
                atomic(inv) {
                    int[] oldContrib = copy(contrib) with { P = 1\4; };
                    lemmaSumCopy(contrib, oldContrib, sum, 0) with { P = 1\4; };
                    assert sum == sumArray(contrib, 0);
                    assert sum == sumArray(oldContrib, 0);

                    int oldSum = sum;
                    sum = sum + A[tid];
                    contrib[tid] = A[tid];
                    lemmaSumUpdate(oldContrib, contrib, oldSum, tid) with { P = 1\4; };
                    assert sum == sumArray(contrib, 0);
                }
            }
        }

        assert (\forall int tid = 0 .. A.length; contrib[tid] == A[tid]);
        assert sum == sumArray(contrib, 0);
        lemmaSumArrEq(contrib, A, 0) with { P = 1\2; };
        assert sum == sumArray(A, 0);
    }
}
