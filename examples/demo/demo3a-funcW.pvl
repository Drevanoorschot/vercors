// -*- tab-width:2 ; indent-tabs-mode:nil -*-
//:: cases demo3a-funcW
//:: tools silicon
//:: verdict Pass
//:: option --disable-par-var-check

class ArraySum {
    requires xs != null;
    requires 0 <= i && i <= xs.length;
    requires (\forall* int j = 0 .. xs.length; Perm(xs[j], read));
    ensures |\result| == (xs.length - i);
    ensures (\forall int j = i .. xs.length; \result[j - i] == xs[j]);
    seq<int> arrayToSeqHelper(int[] xs, int i) =
        i < xs.length
            ? seq<int>{ xs[i] } + arrayToSeqHelper(xs, i + 1)
            : seq<int>{};

    requires xs != null;
    requires (\forall* int i = 0..xs.length; Perm(xs[i], read));
    ensures |\result| == xs.length;
    ensures (\forall int i = 0..xs.length; \result[i] == xs[i]);
    seq<int> arrayToSeq(int[] xs) = arrayToSeqHelper(xs, 0);

    pure int sumSeq(seq<int> xs) = 0 < |xs| ? head(xs) + sumSeq(tail(xs)) : 0;

    context xs != null ** Perm(xs[*], write);
    context (\forall int j = 0 .. xs.length; xs[j] == 0);
    requires 0 <= i && i <= xs.length;
    ensures sumSeq(arrayToSeqHelper(xs, i)) == 0;
    void lemma_sum_init(int[] xs, int i) {
        inhale false;
        if (i < xs.length) {
            assert head(arrayToSeqHelper(xs, i)) == 0;
            lemma_sum_init(xs, i + 1);
            assert arrayToSeqHelper(xs, i + 1) == tail(arrayToSeqHelper(xs, i));
        } else {
            assert sumSeq(arrayToSeqHelper(xs, i)) == 0;
        }
    }

    context_everywhere xs != null;
    context_everywhere Perm(xs[*], 1\4);
    ensures \result != null ** Perm(\result[*], write) ** \result.length == xs.length;
    ensures (\forall int i = 0 .. \result.length; \result[i] == xs[i]);
    int[] copy(int[] xs) {
        inhale false;

        int[] res = new int[xs.length];

        loop_invariant 0 <= i && i <= xs.length;
        loop_invariant Perm(res[*], write) ** res.length == xs.length;
        loop_invariant (\forall int j = 0 .. i; res[j] == xs[j]);
        for (int i = 0; i < xs.length; i++) {
            res[i] = xs[i];
        }

        return res;
    }

//    given frac P;
//    context P != none;
//    context xs != null ** Perm(xs[*], P);
//    context ys != null ** Perm(ys[*], P);
//    context xs.length == ys.length;
//    context 0 <= b && b <= xs.length;
//    context 0 <= i && i < xs.length;
//    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
//    context xs[i] == oldVal;
//    context ys[i] == newVal;
//    requires sumSeq(arrayToSeqHelper(xs, b)) == oldTotal;
//    ensures i < b ==> sumSeq(arrayToSeqHelper(ys, b)) == oldTotal;
//    ensures b <= i ==> sumSeq(arrayToSeqHelper(ys, b)) == (oldTotal - oldVal + newVal);
//    void lemma_sum_update(int[] xs, int[] ys, int b, int oldTotal, int i, int oldVal, int newVal) {
//        if (b < xs.length) {
//            if (i < b) {
//                assert arrayToSeqHelper(xs, b + 1) == tail(arrayToSeqHelper(xs, b));
//                assert arrayToSeqHelper(ys, b + 1) == tail(arrayToSeqHelper(ys, b));
//                lemma_sum_update(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
//                assert i < b + 1;
//                assert sumSeq(arrayToSeqHelper(ys, b + 1)) == (oldTotal - xs[b]);
//            } else {
//                inhale false;
//            }
//        } else {
//            // Not necessary, but:
//            assert oldTotal == 0;
//            assert sumSeq(arrayToSeqHelper(ys, b)) == 0;
//            // Therefore, postcondition holds
//        }
//    }

    given frac P;
    context P != none;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context 0 <= b && b <= xs.length;
    context 0 <= i && i < xs.length;
    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
    context xs[i] == oldVal;
    context ys[i] == newVal;
    requires b <= i;
    requires sumSeq(arrayToSeqHelper(xs, b)) == oldTotal;
    ensures sumSeq(arrayToSeqHelper(ys, b)) == (oldTotal - oldVal + newVal);
    void lemma_sum_update_before(int[] xs, int[] ys, int b, int oldTotal, int i, int oldVal, int newVal) {
//        if (b < xs.length) {
//            if (i < b) {
//                assert arrayToSeqHelper(xs, b + 1) == tail(arrayToSeqHelper(xs, b));
//                assert arrayToSeqHelper(ys, b + 1) == tail(arrayToSeqHelper(ys, b));
//                lemma_sum_update(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
//                assert i < b + 1;
//                assert sumSeq(arrayToSeqHelper(ys, b + 1)) == (oldTotal - xs[b]);
//            } else {
//                inhale false;
//            }
//        } else {
//            // Not necessary, but:
//            assert oldTotal == 0;
//            assert sumSeq(arrayToSeqHelper(ys, b)) == 0;
//            // Therefore, postcondition holds
//        }
        inhale false;
    }

    given frac P;
    context P != none;
    context xs != null ** Perm(xs[*], P);
    context ys != null ** Perm(ys[*], P);
    context xs.length == ys.length;
    context 0 <= b && b <= xs.length;
    context 0 <= i && i < xs.length;
    context (\forall int j = 0 .. xs.length; j != i ==> xs[j] == ys[j]);
    context xs[i] == oldVal;
    context ys[i] == newVal;
    requires i < b;
    requires sumSeq(arrayToSeqHelper(xs, b)) == oldTotal;
    ensures sumSeq(arrayToSeqHelper(ys, b)) == oldTotal;
    void lemma_sum_update_after(int[] xs, int[] ys, int b, int oldTotal, int i, int oldVal, int newVal) {
        if (b < xs.length) {
            // Does our array axiomatisation miss a lemma?
            assert arrayToSeqHelper(xs, b + 1) == tail(arrayToSeqHelper(xs, b));
            lemma_sum_update_after(xs, ys, b + 1, oldTotal - xs[b], i, oldVal, newVal) with { P = P \ 2; };
            // This needs to be after, not before... Strange
            assert arrayToSeqHelper(ys, b + 1) == tail(arrayToSeqHelper(ys, b));
            // Shady, but please give me the lemma's postcondition
            assume sumSeq(arrayToSeqHelper(ys, b + 1)) == oldTotal - xs[b];
        } else {
            // Not necessary, but:
            assert oldTotal == 0;
            assert sumSeq(arrayToSeqHelper(ys, b)) == 0;
            // Therefore, postcondition holds
        }
    }

    requires n >= 5;
    void foo(int n) {
        inhale false;
        int[] xs = new int[n];
        lemma_sum_init(xs, 0);
        assert sumSeq(arrayToSeq(xs)) == 0;

        xs[1] = 1;
        assert sumSeq(arrayToSeq(xs)) == 1;

        xs[3] = 3;

        assert sumSeq(arrayToSeq(xs)) == 4;
    }
//    int sum;
//    seq<int> contrib;
//
//    /* ** Auxiliary definitions */
//
//    requires 0 <= n;
//    ensures |\result| == n;
//    ensures (\forall int i; 0 <= i && i < |\result|; \result[i] == 0);
//    pure seq<int> fresh(int n) = 0 < n ? seq<int> { 0 } + fresh(n - 1) : seq<int> { };
//
//    requires 0 <= j && j < |xs|;
//    ensures |\result| == |xs|;
//    ensures \result[j] == v;
//    ensures (\forall int i; 0 <= i && i < |\result| && i != j; \result[i] == xs[i]);
//    pure seq<int> update(seq<int> xs, int j, int v) =
//        0 < j ? seq<int> { head(xs) } + update(tail(xs), j - 1, v) : seq<int> { v } + tail(xs);
//
//    pure int sum(seq<int> xs) = 0 < |xs| ? head(xs) + sum(tail(xs)) : 0;
//
//
//    /* ** Lemmas */
//
//    requires 0 <= i && i < |xs|;
//    requires xs[i] == 0;
//    ensures sum(update(xs, i, v)) == sum(xs) + v;
//    void lemma_sum_update(seq<int> xs, int i, int v) {
//        if (0 < i) {
//            lemma_sum_update(tail(xs), i - 1, v);
//            assert head(update(xs, i, v)) == head(xs);
//            assert tail(update(xs, i, v)) == update(tail(xs), i - 1, v);
//        }
//        else {
//            assert head(update(xs, i, v)) == v;
//            assert tail(update(xs, i, v)) == tail(xs);
//        }
//    }
//
//    requires 0 <= n;
//    ensures sum(fresh(n)) == 0;
//    void lemma_sum_fresh(int n) {
//        if (0 < n) {
//            lemma_sum_fresh(n - 1);
//            assert head(fresh(n)) == 0;
//            assert tail(fresh(n)) == fresh(n - 1);
//        }
//    }
//
//
//    /* ** Implementation */
//
//    context_everywhere A != null;
//    context (\forall* int i; 0 <= i && i < A.length; Perm(A[i], 1\2));
//    context Perm(this.sum, write);
//    context Perm(this.contrib, write);
//    ensures |contrib| == A.length;
//    ensures (\forall int i; 0 <= i && i < |contrib|; contrib[i] == A[i]);
//    ensures this.sum == sum(this.contrib);
//    void sum(int[] A) {
//        this.contrib = fresh(A.length); // ghost code
//        lemma_sum_fresh(A.length); // ghost code
//
//        this.sum = 0;
//
//        invariant inv(Perm(this.sum, 1) ** Perm(this.contrib, 1\(A.length + 1))
//            ** this.sum == sum(contrib))
//        {
//            par (int tid = 0 .. A.length)
//                context A.length > 0;
//                context Perm(A[tid], 1\2);
//                context Perm(this.contrib, 1\(A.length + 1));
//                context |this.contrib| == A.length;
//                requires this.contrib[tid] == 0;
//                ensures this.contrib[tid] == A[tid];
//            {
//                atomic(inv) {
//                    lemma_sum_update(this.contrib, tid, A[tid]); // ghost code
//                    contrib = update(this.contrib, tid, A[tid]); // ghost code
//
//                    this.sum = this.sum + A[tid];
//                }
//            }
//        }
//    }
}
