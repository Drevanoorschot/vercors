//:: cases SynchronousMoveChannel
//:: suite session-generate
//:: tools silicon
//:: verdict Pass
class MoveChannel {
  boolean transfering;
  Move exchangeValue;
  seq<Move> sent;
  seq<Move> recvd;
  
  resource lock_invariant()=Perm( transfering , 1 ) 
  ** Perm( exchangeValue , 1 ) 
  ** Perm( exchangeValue.i , read ) 
  ** Perm( exchangeValue.j , read ) 
  ** Perm( exchangeValue.token , read ) 
  ** Perm( sent , 1 \ 3 ) 
  ** Perm( recvd , 1 \ 3 ) 
  ** (transfering ==> sent == recvd) 
  ** (! transfering ==> sent == recvd + seq<Move>{exchangeValue});
  
  ensures Perm( sent , 2 \ 3 );
  ensures Perm( recvd , 2 \ 3 );
  ensures (| sent |) == 0;
  ensures (| recvd |) == 0;
  MoveChannel(){
    transfering = true;
    sent = seq<Move>{};
    recvd = seq<Move>{};
    exchangeValue = new Move(0,0,1);
  }
  
  context Perm( sent , 2 \ 3 );
  ensures sent == \old( sent ) ++ v;
  requires Perm( v.i , read ) ** Perm( v.j , read ) ** Perm( v.token , read );
  void writeValue(Move v){
    lock this;
    loop_invariant Perm( transfering , 1 );
    loop_invariant Perm( exchangeValue , 1 );
    loop_invariant Perm( exchangeValue.i , read ) ** Perm( exchangeValue.j , read ) ** Perm( exchangeValue.token , read ) ;
    loop_invariant held( this );
    loop_invariant Perm( sent , 1 );
    loop_invariant Perm( recvd , 1 \ 3 );
    loop_invariant (transfering ==> sent == recvd);
    loop_invariant (! transfering ==> sent == recvd + seq<Move>{exchangeValue});
    loop_invariant sent == \old( sent );
    while(! transfering){
      wait this;
    }
    transfering = false;
    exchangeValue = v;
    sent = sent ++ v;
    notify this;
    unlock this;
  }
  
  context Perm( recvd , 2 \ 3 );
  ensures recvd == \old( recvd ) ++ \result;
  ensures (| recvd |) == \old( | recvd | ) + 1;
  ensures Perm(\result.i , read ) ** Perm( \result.j , read ) ** Perm( \result.token , read );
  Move readValue(){
    lock this;
    loop_invariant Perm( transfering , 1 );
    loop_invariant Perm( exchangeValue , 1 );
    loop_invariant Perm( exchangeValue.i , read ) ** Perm( exchangeValue.j , read ) ** Perm( exchangeValue.token , read );
    loop_invariant held( this );
    loop_invariant Perm( sent , 1 \ 3 );
    loop_invariant Perm( recvd , 1 );
    loop_invariant (transfering ==> sent == recvd);
    loop_invariant (! transfering ==> sent == recvd + seq<Move>{exchangeValue});
    loop_invariant recvd == \old( recvd );
    while(transfering){
      wait this;
    }
    Move v = exchangeValue;
    recvd = recvd ++ v;
    transfering = true;
    notify this;
    unlock this;
    return v;
  }
  
}

