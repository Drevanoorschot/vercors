class MainFJ {
  
  static void MainFJ(){
    Barrier threadBarrier = new Barrier(2);
    MoveChannel p1p2MoveChan = new MoveChannel();
    MoveChannel p2p1MoveChan = new MoveChannel();
    P1Thread p1 = new P1Thread(threadBarrier,p1p2MoveChan,p2p1MoveChan);
    P2Thread p2 = new P2Thread(threadBarrier,p1p2MoveChan,p2p1MoveChan);
    fork p1;
    fork p2;
    join p1;
    join p2;
  }
  
}

class P1Thread {
  Player p1;
  MoveChannel p1p2MoveChan;
  MoveChannel p2p1MoveChan;
  Barrier threadBarrier;
  
  inline resource ticTacToeAnnotations()=Perm( p1 , read ) ** true ** p1.gridWritePerm() ** true ** Perm( p1.move , 1 ) ** true ** Perm( p1.myToken , read ) ** true ** Perm( p1.turn , 1 ) ** true ** true ** true ** true ** true;
  
  requires p1p2MoveChanArg != null;
  requires p2p1MoveChanArg != null;
  requires threadBarrierArg != null;
  ensures Perm( p1p2MoveChan , read );
  ensures Perm( p2p1MoveChan , read );
  ensures p1p2MoveChan == p1p2MoveChanArg;
  ensures p2p1MoveChan == p2p1MoveChanArg;
  ensures Perm( threadBarrier , read );
  ensures threadBarrier != null;
  ensures (ticTacToeAnnotations());
  P1Thread(Barrier threadBarrierArg,MoveChannel p1p2MoveChanArg,MoveChannel p2p1MoveChanArg){
    p1 = new Player(0,true);
    threadBarrier = threadBarrierArg;
    p1p2MoveChan = p1p2MoveChanArg;
    p2p1MoveChan = p2p1MoveChanArg;
  }
  
  context Perm( p2p1MoveChan , read );
  context p2p1MoveChan != null;
  context Perm( p1p2MoveChan , read );
  context p1p2MoveChan != null;
  context Perm( threadBarrier , read );
  context threadBarrier != null;
  context (ticTacToeAnnotations());
  void run(){
    loop_invariant Perm( p1p2MoveChan , read );
    loop_invariant p1p2MoveChan != null;
    loop_invariant Perm( p2p1MoveChan , read );
    loop_invariant p2p1MoveChan != null;
    loop_invariant Perm( threadBarrier , read );
    loop_invariant threadBarrier != null;
    loop_invariant ticTacToeAnnotations();
    while(! p1.gameFinished() && true){
      threadBarrier.await();
      assert true;
      if (p1.turn && true) {
        threadBarrier.await();
        p1.createNewMove();
        p1p2MoveChan.writeValue(p1.move.clone());
      } else {
        threadBarrier.await();
        p1.move = p2p1MoveChan.readValue();
      }
      p1.doMove();
      p1.turn = ! p1.turn;
    }
    threadBarrier.await();
  }
  
}

class P2Thread {
  Player p2;
  MoveChannel p1p2MoveChan;
  MoveChannel p2p1MoveChan;
  Barrier threadBarrier;
  
  inline resource ticTacToeAnnotations()=true ** Perm( p2 , read ) ** true ** p2.gridWritePerm() ** true ** Perm( p2.move , 1 ) ** true ** Perm( p2.myToken , read ) ** true ** Perm( p2.turn , 1 ) ** true ** true ** true ** true;
  
  requires p1p2MoveChanArg != null;
  requires p2p1MoveChanArg != null;
  requires threadBarrierArg != null;
  ensures Perm( p1p2MoveChan , read );
  ensures Perm( p2p1MoveChan , read );
  ensures p1p2MoveChan == p1p2MoveChanArg;
  ensures p2p1MoveChan == p2p1MoveChanArg;
  ensures Perm( threadBarrier , read );
  ensures threadBarrier != null;
  ensures (ticTacToeAnnotations());
  P2Thread(Barrier threadBarrierArg,MoveChannel p1p2MoveChanArg,MoveChannel p2p1MoveChanArg){
    p2 = new Player(1,false);
    threadBarrier = threadBarrierArg;
    p1p2MoveChan = p1p2MoveChanArg;
    p2p1MoveChan = p2p1MoveChanArg;
  }
  
  context Perm( p1p2MoveChan , read );
  context p1p2MoveChan != null;
  context Perm( p2p1MoveChan , read );
  context p2p1MoveChan != null;
  context Perm( threadBarrier , read );
  context threadBarrier != null;
  context (ticTacToeAnnotations());
  void run(){
    loop_invariant Perm( p1p2MoveChan , read );
    loop_invariant p1p2MoveChan != null;
    loop_invariant Perm( p2p1MoveChan , read );
    loop_invariant p2p1MoveChan != null;
    loop_invariant Perm( threadBarrier , read );
    loop_invariant threadBarrier != null;
    loop_invariant ticTacToeAnnotations();
    while(true && ! p2.gameFinished()){
      threadBarrier.await();
      assert true;
      if (true && ! p2.turn) {
        threadBarrier.await();
        p2.move = p1p2MoveChan.readValue();
      } else {
        threadBarrier.await();
        p2.createNewMove();
        p2p1MoveChan.writeValue(p2.move.clone());
      }
      p2.doMove();
      p2.turn = ! p2.turn;
    }
    threadBarrier.await();
  }
  
}

class Move {
  int i;
  int j;
  int token;
  
  ensures Perm( i , read );
  ensures Perm( j , read );
  ensures Perm( token , read );
  Move(int mi,int mj,int mt){
    i = mi;
    j = mj;
    token = mt;
  }
  
  context Perm( i , read );
  context Perm( j , read );
  context Perm( token , read );
  ensures Perm( \result.i , 1 );
  ensures Perm( \result.j , 1 );
  ensures Perm( \result.token , 1 );
  Move clone();
  
}

class Player {
  int c00;
  int c01;
  int c02;
  int c10;
  int c11;
  int c12;
  int c20;
  int c21;
  int c22;
  int myToken;
  Move move;
  boolean turn;
  
  inline resource gridWritePerm()=Perm( c00 , 1 ) ** Perm( c01 , 1 ) ** Perm( c02 , 1 ) ** Perm( c10 , 1 ) ** Perm( c11 , 1 ) ** Perm( c12 , 1 ) ** Perm( c20 , 1 ) ** Perm( c21 , 1 ) ** Perm( c22 , 1 );
  
  ensures Perm( c00 , 1 );
  ensures Perm( c01 , 1 );
  ensures Perm( c02 , 1 );
  ensures Perm( c10 , 1 );
  ensures Perm( c11 , 1 );
  ensures Perm( c12 , 1 );
  ensures Perm( c20 , 1 );
  ensures Perm( c21 , 1 );
  ensures Perm( c22 , 1 );
  ensures Perm( myToken , read );
  ensures Perm( move , 1 );
  ensures Perm( turn , 1 );
  Player(int tok,boolean t){
    c00 = - 1;
    c01 = - 1;
    c02 = - 1;
    c10 = - 1;
    c11 = - 1;
    c12 = - 1;
    c20 = - 1;
    c21 = - 1;
    c22 = - 1;
    myToken = tok;
    turn = t;
  }
  
  context Perm( c00 , 1 );
  context Perm( c01 , 1 );
  context Perm( c02 , 1 );
  context Perm( c10 , 1 );
  context Perm( c11 , 1 );
  context Perm( c12 , 1 );
  context Perm( c20 , 1 );
  context Perm( c21 , 1 );
  context Perm( c22 , 1 );
  context Perm( move , 1 \ 2 );
  context Perm( move.i , read );
  context Perm( move.j , read );
  context Perm( move.token , read );
  void doMove(){
    if (move.i == 0 && move.j == 0) {
      c00 = move.token;
    } else if (move.i == 0 && move.j == 1) {
      c01 = move.token;
    } else if (move.i == 0 && move.j == 2) {
      c02 = move.token;
    } else if (move.i == 1 && move.j == 0) {
      c10 = move.token;
    } else if (move.i == 1 && move.j == 1) {
      c11 = move.token;
    } else if (move.i == 1 && move.j == 2) {
      c12 = move.token;
    } else if (move.i == 2 && move.j == 0) {
      c20 = move.token;
    } else if (move.i == 2 && move.j == 1) {
      c21 = move.token;
    } else if (move.i == 2 && move.j == 2) {
      c22 = move.token;
    }
  }
  
  requires Perm( move , 1 \ 2 );
  requires Perm( move.i , read );
  requires Perm( move.j , read );
  requires Perm( c00 , 1 \ 2 );
  requires Perm( c01 , 1 \ 2 );
  requires Perm( c02 , 1 \ 2 );
  requires Perm( c10 , 1 \ 2 );
  requires Perm( c11 , 1 \ 2 );
  requires Perm( c12 , 1 \ 2 );
  requires Perm( c20 , 1 \ 2 );
  requires Perm( c21 , 1 \ 2 );
  requires Perm( c22 , 1 \ 2 );
  pure int readMoveCell()=move.i == 0 && move.j == 0 ? c00 : (move.i == 0 && move.j == 1 ? c01 : (move.i == 0 && move.j == 2 ? c02 : (move.i == 1 && move.j == 0 ? c10 : (move.i == 1 && move.j == 1 ? c11 : (move.i == 1 && move.j == 2 ? c12 : (move.i == 2 && move.j == 0 ? c20 : (move.i == 2 && move.j == 1 ? c21 : c22)))))));
  
  requires Perm( c00 , 1 \ 2 );
  requires Perm( c01 , 1 \ 2 );
  requires Perm( c02 , 1 \ 2 );
  requires Perm( c10 , 1 \ 2 );
  requires Perm( c11 , 1 \ 2 );
  requires Perm( c12 , 1 \ 2 );
  requires Perm( c20 , 1 \ 2 );
  requires Perm( c21 , 1 \ 2 );
  requires Perm( c22 , 1 \ 2 );
  pure boolean gridFull()=c00 != - 1 && c01 != - 1 && c02 != - 1 && c10 != - 1 && c11 != - 1 && c12 != - 1 && c20 != - 1 && c21 != - 1 && c22 != - 1;
  
  requires Perm( c00 , 1 \ 2 );
  requires Perm( c01 , 1 \ 2 );
  requires Perm( c02 , 1 \ 2 );
  requires Perm( c10 , 1 \ 2 );
  requires Perm( c11 , 1 \ 2 );
  requires Perm( c12 , 1 \ 2 );
  requires Perm( c20 , 1 \ 2 );
  requires Perm( c21 , 1 \ 2 );
  requires Perm( c22 , 1 \ 2 );
  pure boolean gridWin()=(((((((c00 != - 1 && c00 == c01 && c01 == c02 || c10 != - 1) && c10 == c11 && c11 == c12 || c20 != - 1) && c20 == c21 && c21 == c22 || c00 != - 1) && c00 == c10 && c10 == c20 || c01 != - 1) && c01 == c11 && c11 == c21 || c02 != - 1) && c02 == c12 && c12 == c22 || c00 != - 1) && c00 == c11 && c11 == c22 || c02 != - 1) && c02 == c11 && c11 == c20;
  
  requires Perm( c00 , 1 \ 2 );
  requires Perm( c01 , 1 \ 2 );
  requires Perm( c02 , 1 \ 2 );
  requires Perm( c10 , 1 \ 2 );
  requires Perm( c11 , 1 \ 2 );
  requires Perm( c12 , 1 \ 2 );
  requires Perm( c20 , 1 \ 2 );
  requires Perm( c21 , 1 \ 2 );
  requires Perm( c22 , 1 \ 2 );
  pure boolean gameFinished()=gridFull() || gridWin();
  
  requires Perm( c00 , 1 \ 2 );
  requires Perm( c01 , 1 \ 2 );
  requires Perm( c02 , 1 \ 2 );
  requires Perm( c10 , 1 \ 2 );
  requires Perm( c11 , 1 \ 2 );
  requires Perm( c12 , 1 \ 2 );
  requires Perm( c20 , 1 \ 2 );
  requires Perm( c21 , 1 \ 2 );
  requires Perm( c22 , 1 \ 2 );
  requires Perm( other.c00 , 1 \ 2 );
  requires Perm( other.c01 , 1 \ 2 );
  requires Perm( other.c02 , 1 \ 2 );
  requires Perm( other.c10 , 1 \ 2 );
  requires Perm( other.c11 , 1 \ 2 );
  requires Perm( other.c12 , 1 \ 2 );
  requires Perm( other.c20 , 1 \ 2 );
  requires Perm( other.c21 , 1 \ 2 );
  requires Perm( other.c22 , 1 \ 2 );
  pure boolean equalGrid(Player other)=c00 == other.c00 && c01 == other.c01 && c02 == other.c02 && c10 == other.c10 && c11 == other.c11 && c12 == other.c12 && c20 == other.c20 && c21 == other.c21 && c22 == other.c22;
  
  context Perm( move , 1 );
  context Perm( myToken , read );
  context Perm( c00 , 1 \ 2 );
  context Perm( c01 , 1 \ 2 );
  context Perm( c02 , 1 \ 2 );
  context Perm( c10 , 1 \ 2 );
  context Perm( c11 , 1 \ 2 );
  context Perm( c12 , 1 \ 2 );
  context Perm( c20 , 1 \ 2 );
  context Perm( c21 , 1 \ 2 );
  context Perm( c22 , 1 \ 2 );
  ensures Perm( move.i , read );
  ensures Perm( move.j , read );
  ensures Perm( move.token , read );
  void createNewMove();
  
}

class MoveChannel {
  boolean transfering;
  Move exchangeValue;
  
  resource lock_invariant()=Perm( transfering , 1 ) ** Perm( exchangeValue , 1 ) ** (Perm( exchangeValue.i , read ) ** Perm( exchangeValue.j , read ) ** Perm( exchangeValue.token , read ));
  
  MoveChannel(){
    transfering = true;
    exchangeValue = new Move(0,0,0);
  }
  
  context Perm( v.i , read );
  context Perm( v.j , read );
  context Perm( v.token , read );
  void writeValue(Move v){
    lock this;
    loop_invariant Perm( transfering , 1 );
    loop_invariant Perm( exchangeValue , 1 );
    loop_invariant held( this );
    loop_invariant Perm( exchangeValue.i , read );
    loop_invariant Perm( exchangeValue.j , read );
    loop_invariant Perm( exchangeValue.token , read );
    while(! transfering){
      wait this;
    }
    transfering = false;
    exchangeValue = v;
    notify this;
    unlock this;
  }
  
  ensures Perm( \result.i , read );
  ensures Perm( \result.j , read );
  ensures Perm( \result.token , read );
  Move readValue(){
    lock this;
    loop_invariant Perm( transfering , 1 );
    loop_invariant Perm( exchangeValue , 1 );
    loop_invariant held( this );
    loop_invariant Perm( exchangeValue.i , read );
    loop_invariant Perm( exchangeValue.j , read );
    loop_invariant Perm( exchangeValue.token , read );
    while(transfering){
      wait this;
    }
    Move v = exchangeValue;
    transfering = true;
    notify this;
    unlock this;
    return v;
  }
  
}

class Barrier {
  int k;
  int n;
  boolean outgoing;
  
  resource lock_invariant()=Perm( k , 1 ) ** Perm( n , read ) ** Perm( outgoing , 1 ) ** 0 <= k ** k < n ** (outgoing ? 1 <= k : 0 <= k) ** n > 1;
  
  requires nrThreads > 1;
  Barrier(int nrThreads){
    n = nrThreads;
    k = 0;
    outgoing = false;
  }
  
  void await(){
    lock this;
    loop_invariant held( this );
    loop_invariant Perm( k , 1 );
    loop_invariant Perm( n , read );
    loop_invariant Perm( outgoing , 1 );
    loop_invariant k < n;
    loop_invariant (outgoing ? 1 <= k : 0 <= k);
    loop_invariant n > 1;
    while(outgoing){
      wait this;
    }
    k ++;
    if (k == n) {
      outgoing = true;
      k --;
      loop_invariant Perm( n , read );
      loop_invariant (1 <= i && i <= n);
      loop_invariant held( this );
      for(int i = 1;i < n;i ++){
        notify this;
      }
    } else {
      loop_invariant held( this );
      loop_invariant Perm( k , 1 );
      loop_invariant Perm( n , read );
      loop_invariant Perm( outgoing , 1 );
      loop_invariant k < n;
      loop_invariant (outgoing ? 1 <= k : 0 <= k);
      loop_invariant n > 1;
      while(! outgoing){
        wait this;
      }
      k --;
      if (k == 0) {
        outgoing = false;
        loop_invariant Perm( n , read );
        loop_invariant (1 <= i && i <= n);
        loop_invariant held( this );
        for(int i = 1;i < n;i ++){
          notify this;
        }
      }
    }
    unlock this;
  }
  
}

