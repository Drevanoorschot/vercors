// -*- tab-width:4 ; indent-tabs-mode:nil -*-
//:: cases TicTacToeInt TicTacToeMatrix
//:: tools silicon
//:: verdict Pass

class Main {
	
	Grid P1,P2;
	
	inline resource ticTacToeAnnotations() = Perm(P1,read) ** Perm(P2,read)
	** P1.gridWritePerm() ** P2.gridWritePerm()
	** Perm(P1.move,1) ** Perm(P2.move,1)
	** Perm(P1.myToken,read) ** Perm(P2.myToken,read)
	** Perm(P1.turn,1) ** Perm(P2.turn,1)
	** P1.myToken == 0 ** P2.myToken == 1
	** P1.equals(P2); 
	
	ensures (ticTacToeAnnotations());
	Main() {
		P1 = new Grid(0,true);
		P2 = new Grid(1,false);	
	}
	
	context (ticTacToeAnnotations());		  
//	context P1.turn != P2.turn;
	ensures P1.gameFinished() && P2.gameFinished();
	void run() {	  
		loop_invariant Perm(P1,read) ** Perm(P2,read);
		loop_invariant P1.gridWritePerm();
		loop_invariant P2.gridWritePerm();
	    loop_invariant Perm(P1.move,1) ** Perm(P1.myToken, read);
	    loop_invariant Perm(P2.move,1) ** Perm(P2.myToken, read);
	    loop_invariant Perm(P1.turn,1) ** Perm(P2.turn,1);
	    loop_invariant P1.equals(P2);
	//	loop_invariant P1.gameFinished() == P2.gameFinished(); this invariant is not necessary with the equals invariant
		loop_invariant P1.myToken == 0;
		loop_invariant P2.myToken == 1;
	//	loop_invariant P1.turn != P2.turn; //invariant not needed
		while(!P1.gameFinished() && !P2.gameFinished()) {
			if(P1.turn && !P2.turn) {
				P1.createNewMove();
				P2.move = P1.move;
			} else {
				P2.createNewMove();
				P1.move = P2.move;
			}
			P1.doMove();
			P2.doMove();
			P1.turn = !P1.turn;
			P2.turn = !P2.turn;
		}
	}
	
	void main() {
		Main m = new Main();
		m.run();
	}

}
