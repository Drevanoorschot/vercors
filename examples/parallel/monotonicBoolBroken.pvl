//:: case MonotonicBoolBroken
//:: tool silicon
//:: verdict Pass

// This file demonstrates that monotonicBool.pvl is _not_ truly a monotonic bool, and shows
// how to break it. Notice that this is possible because in PVL there is no such thing as ghost state.
// In C/Java, this approach is only possible of contrib is not a ghost array. Still, this implies
// if the runtime checking for monotonicity is implemented with an invariant like this, it could be
// circumvented!!

class C {
  boolean b;
  boolean[] contrib;

  // Useful for random choice
  int p();

  ensures \result == (\exists int i = 0..|xs|; xs[i]);
  boolean foldOr(seq<boolean> xs) =
    |xs| > 0 
      ? head(xs) || foldOr(tail(xs))
      : false;

  requires Perm(contrib, write);
  requires Perm(b, write);
  requires N > 0;
  void foo(int N) {
    b = false;
    contrib = new boolean[N];
    assert b == foldOr(\values(contrib, 0, N));

    assert Perm(contrib, read);
    assert (\forall* int i = 0..N; Perm(contrib, read));

    invariant inv(Perm(contrib, read)
        ** contrib.length == N
        ** (\forall* int i = 0..N; Perm(contrib[i], 1\2))
        ** Perm(b, write)
        ** b == foldOr(\values(contrib, 0, N))
        ) {
      par(int tid = 0..N)
        context N > 0;
        context Perm(contrib, read) ** contrib != null;
        context Perm(contrib[tid], 1\2);
      {
        // First, we set the bool with a 50% chance
        // Then, if nobody else set it in the meantime, we undo our set with a very small chance!!

        if (p() % 2 == 0) {
          // Models: atomic_set(b);
          atomic(inv) {
            b = true;
            contrib[tid] = true;
          }
        }

        if (p() == 666) {
          // The stars have aligned!
          // Try evil unset also!
          atomic(inv) {
            boolean evilCondition = true;

            // Check if we are the only one that set it since last time
            loop_invariant 0 <= k && k <= N;
            loop_invariant Perm(contrib, read) ** contrib != null ** contrib.length == N;
            loop_invariant (\forall* int i = 0..N; Perm(contrib[i], 1\100));
            loop_invariant evilCondition == (\forall int j = 0 .. k; j == tid ? contrib[j] : !contrib[j]);
            for (int k = 0; k < N; k++) {
              if (k == tid) {
                evilCondition = evilCondition && contrib[k];
              } else {
                evilCondition = evilCondition && !contrib[k];
              }
            }

            // If so, we hide our action!!!!!
            if (evilCondition) {
              b = false;
              contrib[tid] = false;
            }
          }
        }
      }
    }

    assert b == (\exists int i = 0..N; contrib[i]);
  }
}
