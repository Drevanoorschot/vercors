//:: case MonotonicBool
//:: tool silicon
//:: verdict Pass

// This file contains an attempt at constructing and verifying a monotonic bool.
// It would seem that it is truly a monotonic bool, since if one of
// the threads write false to b the program does not verify.
// However, approach is unfortunately not correct; see monotonicBoolBroken.pvl in the same folder for details.

class C {
  boolean b;
  boolean[] contrib;

  // Method that might return true or false. Useful for setting the bool "sometimes"
  boolean p(int tid);

  ensures \result == (\exists int i = 0..|xs|; xs[i]);
  boolean foldOr(seq<boolean> xs) =
    |xs| > 0 
      ? head(xs) || foldOr(tail(xs))
      : false;

  requires Perm(contrib, write);
  requires Perm(b, write);
  requires N > 0;
  void foo(int N) {
    b = false;
    contrib = new boolean[N];
    assert b == foldOr(\values(contrib, 0, N));

    assert Perm(contrib, read);
    assert (\forall* int i = 0..N; Perm(contrib, read));

    invariant inv(Perm(contrib, read) 
        ** contrib.length == N
        ** (\forall* int i = 0..N; Perm(contrib[i], 1\2))
        ** Perm(b, write)
        ** b == foldOr(\values(contrib, 0, N))
        ) {
      par(int tid = 0..N)
        context N > 0;
        context Perm(contrib, read) ** contrib != null;
        context Perm(contrib[tid], 1\2);
      {
        if (p(tid)) {
          // Models: atomic_set(b);
          atomic(inv) {
            b = true;
            contrib[tid] = true;
            // Fails:
            // b = false;
            // contrib[tid] = false;
          }
        }
      }
    }

    assert b == (\exists int i = 0..N; contrib[i]);
  }
}
