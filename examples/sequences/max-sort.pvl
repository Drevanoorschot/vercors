class MaxSort {

    ensures MaxSort.sorted(\result);
    seq<int> maxsort(seq<int> input) {
        seq<int> unsorted = input;
        seq<int> result = [t:int];

        loop_invariant |input| == |result| + |unsorted|;
        loop_invariant (\forall int l; 0 <= l && l < |result|; result[l] in input);
        loop_invariant (\forall int l; 0 <= l && l < |unsorted|; unsorted[l] in input);
        loop_invariant !empty(unsorted) ==> (\forall int l; 0 <= l && l < |result|; result[l] >= unsorted[MaxSort.max(unsorted)]);
        loop_invariant MaxSort.sorted(result);
        while (!empty(unsorted)) {
            int maxOfSeq = MaxSort.max(unsorted);            //assert (\forall int l; 0 <= l && l < |unsorted|; unsorted[l] <= unsorted[maxOfSeq]);
            result = unsorted[maxOfSeq] :: result;
            assert unsorted[maxOfSeq] == head(result);
            unsorted = remove(unsorted, maxOfSeq);
        }
        return result;
    }

    requires |xs| > 0;
    ensures 0 <= \result && \result < |xs|;
    ensures (\forall int i; 0 <= i && i < |xs|; xs[i] <= xs[\result]);
    pure static int max(seq<int> xs) = MaxSort.maxhelper(xs, 0);


    requires |xs| > 0;
    requires 0 <= j && j < |xs|;
    ensures 0 <= \result && \result < |xs|;
    ensures \result >= j;
    ensures (\forall int i; j <= i && i < |xs|; xs[i] <= xs[\result]);
    pure static int maxhelper(seq<int> xs, int j) =
        j == |xs|-1 ?
            j:
            (xs[j] > xs[MaxSort.maxhelper(xs, j+1)] ?
                j:
                MaxSort.maxhelper(xs, j+1)
            )
    ;

	pure static boolean sorted(seq<int> xs) = (\forall int i ; 0 <= i && i < |xs|-1; xs[i] <= xs[i+1]);

}
