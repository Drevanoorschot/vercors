class MinMaxSort {
    ensures |\result| == |input|;
    ensures MinMaxSort.sorted(\result);
    seq<int> MinMaxSort(seq<int> input) {
        seq<int> unsorted = input;
        seq<int> left = [t:int];
        seq<int> right = [t:int];

        loop_invariant |input| == |left| + |right| + |unsorted|;
        loop_invariant (\forall int l; 0 <= l && l < |left|; left[l] in input);
        loop_invariant (\forall int l; 0 <= l && l < |right|; right[l] in input);
        loop_invariant (\forall int l; 0 <= l && l < |unsorted|; unsorted[l] in input);
        loop_invariant !empty(unsorted) ==> (\forall int l; 0 <= l && l < |right|; right[l] >= unsorted[MinMaxSort.max(unsorted)]);
        loop_invariant !empty(unsorted) ==> (\forall int l; 0 <= l && l < |left|; left[l] <= unsorted[MinMaxSort.min(unsorted)]);
        loop_invariant (\forall int l; 0 <= l && l < |left|;
            (\forall int k; 0 <= k && k < |right|; left[l] <= right[k])
        );
        loop_invariant MinMaxSort.sorted(left);
        loop_invariant MinMaxSort.sorted(right);
        while (|unsorted| >= 2) {
            int maxOfSeq = MinMaxSort.max(unsorted);            //assert (\forall int l; 0 <= l && l < |unsorted|; unsorted[l] <= unsorted[maxOfSeq]);
            right = unsorted[maxOfSeq] :: right;
            unsorted = remove(unsorted, maxOfSeq);

            int minOfSeq = MinMaxSort.min(unsorted);            //assert (\forall int l; 0 <= l && l < |unsorted|; unsorted[l] <= unsorted[maxOfSeq]);
            left = left ++ unsorted[minOfSeq];
            unsorted = remove(unsorted, minOfSeq);
        }
        return left + unsorted +  right;
    }

    requires |xs| > 0;
    ensures 0 <= \result && \result < |xs|;
    ensures (\forall int i; 0 <= i && i < |xs|; xs[i] <= xs[\result]);
    pure static int max(seq<int> xs) = MinMaxSort.maxhelper(xs, 0);


    requires |xs| > 0;
    requires 0 <= j && j < |xs|;
    ensures 0 <= \result && \result < |xs|;
    ensures \result >= j;
    ensures (\forall int i; j <= i && i < |xs|; xs[i] <= xs[\result]);
    pure static int maxhelper(seq<int> xs, int j) =
        j == |xs|-1 ?
            j:
            (xs[j] > xs[MinMaxSort.maxhelper(xs, j+1)] ?
                j:
                MinMaxSort.maxhelper(xs, j+1)
            )
    ;

    requires |xs| > 0;
    ensures 0 <= \result && \result < |xs|;
    ensures (\forall int i; 0 <= i && i < |xs|; xs[i] >= xs[\result]);
    pure static int min(seq<int> xs) = MinMaxSort.minhelper(xs, 0);


    requires |xs| > 0;
    requires 0 <= j && j < |xs|;
    ensures 0 <= \result && \result < |xs|;
    ensures \result >= j;
    ensures (\forall int i; j <= i && i < |xs|; xs[i] >= xs[\result]);
    pure static int minhelper(seq<int> xs, int j) =
        j == |xs|-1 ?
            j:
            (xs[j] < xs[MinMaxSort.minhelper(xs, j+1)] ?
                j:
                MinMaxSort.minhelper(xs, j+1)
            )
    ;

    pure static boolean sorted(seq<int> xs) = (\forall int i ; 0 <= i && i < |xs|-1; xs[i] <= xs[i+1]);

}

