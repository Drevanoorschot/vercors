package silAST.statements

import silAST.ASTNode
import silAST.expressions.ProgramExpression
import silAST.expressions.util.PArgumentSequence
import silAST.symbols.{ProgramVariableSequence,Method,Field,ProgramVariable}
import silAST.types.DataType
import silAST.expressions.Expression
import silAST.expressions.PredicateExpression

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
sealed abstract class Statement extends ASTNode 
{
	override def toString : String
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class Assignment(
                                target : ProgramVariable,
    source : ProgramExpression
    ) 
    extends Statement 
{
	override def toString : String = target.name + ":=" + source.toString
	override def subNodes : Seq[ASTNode] = List(target,source)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class FieldAssignment(
                                     target : ProgramVariable,
    field  : Field,
    source : ProgramExpression
    ) 
    extends Statement 
{
	override def toString : String = target.name + "." + field.name + " := " + source.toString
	override def subNodes : Seq[ASTNode] = List(target,field,source)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class NewStatement(
                                  target : ProgramVariable,
    dataType : DataType
    ) 
    extends Statement 
{
	override def toString : String = target.name + ":= new " + dataType.toString
	override def subNodes : Seq[ASTNode] = List(target,dataType)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class CallStatement(
                                   targets : ProgramVariableSequence,
    receiver : ProgramExpression,
    method : Method,
    arguments : PArgumentSequence
    ) 
    extends Statement 
{
	override def toString : String = targets.toString + " := " + receiver.toString + "." + method.name + arguments.toString
	override def subNodes : Seq[ASTNode] = List(targets,receiver,method,arguments)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class inhale(
                            expression : Expression
    ) 
    extends Statement 
{
	override def toString : String = "inhale " + expression.toString
	override def subNodes : Seq[ASTNode] = List(expression)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class exhale(
                            expression : Expression
    ) 
    extends Statement 
{
	override def toString : String = "exhale " + expression.toString
	override def subNodes : Seq[ASTNode] = List(expression)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//TODO:fold/unfold arrays?
abstract case class fold(
                          predicate : PredicateExpression
    ) 
    extends Statement 
{
	override def toString : String = "fold " + predicate.toString
	override def subNodes : Seq[ASTNode] = List(predicate)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class unfold(
                            predicate : PredicateExpression
    ) 
    extends Statement 
{
	override def toString : String = "unfold " + predicate.toString
	override def subNodes : Seq[ASTNode] = List(predicate)
}
