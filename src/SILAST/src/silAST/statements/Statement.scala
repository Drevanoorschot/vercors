package silAST.statements

import silAST.ASTNode
import silAST.source.SourceLocation
import silAST.expressions.ProgramExpression
import silAST.expressions.util.PArgumentSequence
import silAST.symbols.{ProgramVariableSequence,Method,Field,ProgramVariable}
import silAST.types.DataType
import silAST.expressions.Expression
import silAST.expressions.PredicateExpression

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
sealed abstract class Statement extends ASTNode 
{
	override def toString : String
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class Assignment( 
		val target : ProgramVariable,
		val source : ProgramExpression
    ) 
    extends Statement 
{
	override def toString : String = target.name + ":=" + source.toString
	override def subNodes : Seq[ASTNode] = List(target,source)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class FieldAssignment( 
		val target : ProgramVariable,
		val field  : Field,
		val source : ProgramExpression
    ) 
    extends Statement 
{
	override def toString : String = target.name + "." + field.name + " := " + source.toString
	override def subNodes : Seq[ASTNode] = List(target,field,source)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class NewStatement( 
		val target : ProgramVariable,
		val dataType : DataType
    ) 
    extends Statement 
{
	override def toString : String = target.name + ":= new " + dataType.toString
	override def subNodes : Seq[ASTNode] = List(target,dataType)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class CallStatement( 
		val targets : ProgramVariableSequence,
		val receiver : ProgramExpression,
		val method : Method,
		val arguments : PArgumentSequence
    ) 
    extends Statement 
{
	override def toString : String = targets.toString + " := " + receiver.toString + "." + method.name + arguments.toString
	override def subNodes : Seq[ASTNode] = List(targets,receiver,method,arguments)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class inhale( 
		val expression : Expression
    ) 
    extends Statement 
{
	override def toString : String = "inhale " + expression.toString
	override def subNodes : Seq[ASTNode] = List(expression)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class exhale( 
		val expression : Expression
    ) 
    extends Statement 
{
	override def toString : String = "exhale " + expression.toString
	override def subNodes : Seq[ASTNode] = List(expression)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//TODO:fold/unfold arrays?
abstract case class fold( 
		val predicate : PredicateExpression
    ) 
    extends Statement 
{
	override def toString : String = "fold " + predicate.toString
	override def subNodes : Seq[ASTNode] = List(predicate)
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
abstract case class unfold( 
		val predicate : PredicateExpression
    ) 
    extends Statement 
{
	override def toString : String = "unfold " + predicate.toString
	override def subNodes : Seq[ASTNode] = List(predicate)
}
