var v: Int
var n: Ref

predicate List(xs: Ref) {
	acc(xs.v) && acc(xs.n) && (xs.n != null ==> acc(List(xs.n)))
}

function elems(xs: Ref): Seq[Int]
  requires acc(List(xs))
{ unfolding List(xs) in Seq(xs.v) ++ (xs.n == null ? Seq[Int]() : elems(xs.n)) }

function head(xs: Ref): Int
  requires acc(List(xs))
{ unfolding List(xs) in xs.v }

method insert(xs: Ref, x: Int) returns (i: Int)
  requires acc(List(xs))
  requires head(xs) < x
  ensures acc(List(xs))
  ensures elems(xs) == (old(elems(xs))[0..i+1] ++ Seq(x) ++ (old(elems(xs))[i+1..]))
{
  var curr: Ref
  var next: Ref
  i := 0

  letass A := acc(List(curr))
  letass B := acc(List(xs)) && elems(xs) == ((old(elems(xs))[0..i]) ++ given(elems(curr)))

  unfold List(xs)
  curr := xs
  next := xs.n

  package A --* B;

  while (next != null && head(next) < x)
    invariant (0 <= i) && (i < |old(elems(xs))|);
    invariant acc(curr.v) && acc(curr.n);
    invariant next == (curr.n);
    invariant (curr.v) == (old(elems(xs))[i]); /* inv4 */
    invariant (next != null) ==> (acc(List(next)) && (elems(next) == (old(elems(xs))[i+1..])));
    invariant A --* B;
  {
    assert (old(elems(xs))[i+1..]) == elems(next);
      /* Can be shown */
    assume (old(elems(xs))[i+1]) == unfolding List(next) in next.v;
      /* Cannot be shown by Silicon, and thus INV4 cannot be shown at the end of the loop */

    letwand w := A --* B;

    var prev: Ref
    prev := curr

    unfold List(next)
    curr := next
    next := next.n
    i := i + 1

    assert curr.v == (old(elems(xs))[i]); /* INV4 */

    package A --* folding List(prev) in applying w in B;
  }

  var node: Ref
  node := new()
  node.v := x
  node.n := next

  fold List(node)
  assert elems(node) == (Seq(x) ++ (old(elems(xs))[i+1..])); /* Silicon function unrolling? */

  curr.n := node
  fold List(curr)

  apply A --* B
}
