field f: Bool
field g: Int
field h: Ref

predicate M(x: Ref) { true }
predicate B(x: Ref) { acc(x.f) }
predicate T(x: Ref) { true }
predicate E(x: Ref) { true }

//method test15(x: Ref, b: Bool)
//  requires acc(x.f) && acc(x.g)
//{
////  package (b ==> acc(x.f)) --* acc(x.g) // TODO: Allow impure conditionals
//  package acc(x.f, b ? write : none) --* acc(x.g)
//}

function get(x: Ref, i: Int): Bool
//  requires acc(B(x))
//{ unfolding acc(B(x)) in x.f }
{ i != 0 }

//method test01(x: Ref, i: Int)
//  requires acc(M(x))
//{
//  package true --* (i == 0 ==> acc(M(x)))
//
//  assert true --* (i == 0 ==> acc(M(x)))
//  assert i != 0 ==> acc(M(x))
//
//  //:: ExpectedOutput(assert.failed:insufficient.permission)
//  assert acc(M(x))
//}
//
//method test04(x: Ref, i: Int)
//  requires acc(T(x)) && acc(E(x))
//{
//  package true --* (i == 0 ? acc(T(x)) : acc(E(x)))
//
//  //:: ExpectedOutput(assert.failed:insufficient.permission)
//  assert i == 0 ==> acc(T(x))
//}
//
//method test03(x: Ref, i: Int)
//  requires acc(T(x)) && acc(E(x))
//{
//  package true --* (i == 0 ? acc(T(x)) : acc(E(x)))
//
//  assert i != 0 ==> acc(T(x))
//  assert i == 0 ==> acc(E(x))
//
//  assert i == 0 ? acc(E(x)) : acc(T(x))
//
//  //:: ExpectedOutput(assert.failed:insufficient.permission)
//  assert acc(E(x)) && acc(T(x))
//}
//
//method test05(x: Ref, i: Int)
//  requires acc(M(x)) && acc(B(x)) && acc(T(x)) && acc(E(x))
//{
//  package acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//
//  assert get(x, i) ? acc(E(x)) : acc(T(x))
//
//  //:: ExpectedOutput(assert.failed:insufficient.permission)
//  assert acc(E(x)) && acc(T(x))
//}
//
//method test06(x: Ref, i: Int)
//  requires acc(M(x)) && acc(B(x)) && acc(T(x)) && acc(E(x))
//{
//  package acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//  apply acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//
//  assert acc(B(x)) && acc(E(x)) && acc(T(x))
//}
//
//method test07(x: Ref, i: Int)
//  requires acc(M(x)) && acc(B(x)) && acc(T(x)) && acc(E(x))
//{
//  package acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//  apply acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//
//  assert acc(B(x)) && acc(E(x)) && acc(T(x))
//
//  //:: ExpectedOutput(assert.failed:assertion.false)
//  assert false
//}
//
//method test10(x: Ref, i: Int)
//  requires acc(M(x)) && acc(B(x)) && acc(T(x)) && acc(E(x))
//{
//  if (i == 0) {
//    package acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//    assert acc(T(x))
//  } else {
//    package acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//    assert acc(E(x))
//  }
//
//  apply acc(M(x)) --* acc(B(x)) && (get(x, i) ? acc(T(x)) : acc(E(x)))
//
//  assert acc(B(x)) && acc(T(x)) && acc(E(x))
//
//  //:: ExpectedOutput(assert.failed:assertion.false)
//  assert false
//}

//method test11(x: Ref, b: Bool)
//  requires acc(x.g) && acc(x.h)
//{
////  package true --* (b ? acc(x.g) : acc(x.h)) // TODO: Allow impure conditionals
//  package true --* acc(x.g, b ? write : none) && acc(x.h, b ? none : write)
//
//  if (b) {
//    assert perm(x.g) == none && perm(x.h) == write
//  } else {
//    assert perm(x.g) == write && perm(x.h) == none
//  }
//}

method test12(x: Ref)
  requires acc(x.f) && acc(x.g, 2/3) && acc(x.h, 2/3)
{
  define A acc(x.f)

  // TODO: Allow impure conditionals
  define B acc(x.f) /*&& x.f == lhs(x.f)*/ &&
           acc(x.g, x.f ? 1/2 : none) &&
           acc(x.h, !x.f ? 2/3 : none)

  package A --* B

//  assert acc(x.f)
//  assert perm(x.g) + perm(x.h) == write

  apply A --* B

//  assert acc(x.f)
  assert acc(x.g, 1/2)
  assert acc(x.h, 2/3)

//  var b: Bool
//  if (b) {
//    x.f := b
//    apply A --* B
//    assert true /* TODO: Triggers a heap compression - should not be necessary */
//    assert acc(x.f) && acc(x.g) && acc(x.h)
//  } else {
//    x.f := b
//    apply A --* B
//    assert acc(x.f) && acc(x.g) && acc(x.h)
//  }
}

//method test14(x: Ref)
//  requires acc(x.f)
//  requires acc(x.f)
//              --*
//           acc(x.f) && x.f == lhs(x.f) &&
//           acc(x.g, x.f ? write : 1/10) &&
//           acc(x.h, x.f ? 1/10 : write)
//{
//  apply acc(x.f)
//           --*
//        acc(x.f) && x.f == lhs(x.f) &&
//        acc(x.g, x.f ? write : 1/10) &&
//        acc(x.h, x.f ? 1/10 : write)
//
//  assert x.f ? perm(x.g) == write : perm(x.h) == write
//
//  //:: ExpectedOutput(assert.failed:assertion.false)
//  assert perm(x.g) == write && perm(x.h) == write
//}

//method testXZY(x: Ref, n: Int)
//  requires acc(x.g)
//  requires x.g == n
//{
//  package acc(x.g) --* acc(x.g)
//  apply acc(x.g) --* acc(x.g)
//  assert x.g == n /* TODO: Currently fails */
//}
