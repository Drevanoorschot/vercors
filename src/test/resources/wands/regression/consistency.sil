/* Consistency checks (performed on the real Silver AST, not the parser AST) */

field f: Int
field g: Int

predicate Pair(this: Ref) {
  acc(this.f) && acc(this.g)
}

method test01(p: Ref)
  //:: ExpectedOutput(typechecker.error)
  requires acc(p.f) --* folding Pair(p) in true
    /* Wands outside of package-statements should be ghost-operation-free */
{}

method test04(p: Ref)
  requires acc(p.f) --* acc(Pair(p))
{
  exhale
    acc(p.f)
      --*
    //:: ExpectedOutput(typechecker.error)
    (applying (acc(p.f) --* acc(Pair(p))) in true)
      /* Wands outside of package-statements should be ghost-operation-free */
}

method test02(p: Ref)
  requires acc(Pair(p))
  //:: ExpectedOutput(typechecker.error)
  requires unfolding Pair(p) in acc(p.f)
    /* Ghost operations that occur in (potential) inhale positions must be pure */
{}

method test03() {
  var p: Ref
  p := new()

  //:: ExpectedOutput(typechecker.error)
  assert folding Pair(p) in acc(Pair(p))
}

method test05(p: Ref) {
  //:: ExpectedOutput(typechecker.error)
  apply (folding Pair(p) in true) --* true
    /* Wands outside of package-statements should be ghost-operation-free */
}

method test08(p: Ref) {
  //:: ExpectedOutput(typechecker.error)
  package (folding Pair(p) in true) --* true
    /* Ghost operations on the left of a wand are not supported (and not
     * necessary, they could be performed outside of the wand)
     */
}

method test10(p: Ref) {
  //:: ExpectedOutput(typechecker.error)
  assert applying ((folding Pair(p) in true) --* true) in true
    /* Wands outside of packaging-expressions should be ghost-operation-free */
}

method test11(p: Ref) {
  //:: ExpectedOutput(typechecker.error)
  assert packaging ((folding Pair(p) in true) --* true) in true
    /* Ghost operations on the left of a wand are not supported (and not
     * necessary, they could be performed outside of the wand)
     */
}

function fun(x: Ref): Int
  requires true --* acc(x.f)
{
  //:: ExpectedOutput(typechecker.error)
  applying (true --* acc(x.f)) in x.f
}

method test12(x: Ref)
  requires acc(x.f)
  requires true --* acc(x.g)
{
  //:: ExpectedOutput(typechecker.error)
  package true --* acc(x.f) && applying (true --* acc(x.g)) in true
}

method test13(x: Ref)
  requires acc(x.f)
  requires true --* acc(x.g)
{
  //:: ExpectedOutput(typechecker.error)
  package true --* (applying (true --* acc(x.g)) in true) && acc(x.f)
}

method test14(x: Ref)
  requires true --* acc(x.f)
  requires true --* acc(x.g)
{
  //:: ExpectedOutput(typechecker.error)
  package true --* (applying (true --* acc(x.f)) in acc(x.f)) && (applying (true --* acc(x.g)) in acc(x.g))
}

method test15(x: Ref, b: Bool)
  requires true --* acc(x.f)
  requires true --* acc(x.g)
{
  //:: ExpectedOutput(typechecker.error)
  package true --* b ? (applying (true --* acc(x.g)) in acc(x.g)) : (applying (true --* acc(x.f)) in acc(x.f))
}

method test16(x: Ref, b: Bool)
  requires true --* acc(x.f)
{
  //:: ExpectedOutput(typechecker.error)
  package true --* b ==> (applying (true --* acc(x.f)) in acc(x.f))
}
