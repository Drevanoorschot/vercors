/* TODO: Implement error annotations for parser and type-checker errors. */

//var f: Int
//var g: Int
//
//predicate Pair(this: Ref) {
//  acc(this.f, write) && acc(this.g, write)
//}
//
///* Wands outside of package-statements should be ghost-operation-free */
//method test01(p: Ref)
//  requires acc(p.f, write) --* folding acc(Pair(p), write) in true // ERROR
//{}
//
///* Wands outside of package-statements should be ghost-operation-free */
//method test04(p: Ref)
//  requires acc(p.f, write) --* acc(Pair(p), write)
//{
//  exhale
//    acc(p.f, write)
//      --*
//    (applying (acc(p.f, write) --* acc(Pair(p), write)) in true) // ERROR
//}
//
///* Ghost operations outside of package statements must be pure */
//method test02(p: Ref)
//  requires acc(Pair(p), write)
//  requires unfolding acc(Pair(p), write) in acc(p.f, write) // ERROR
//{}
//
///* Ghost operations outside of package statements must be pure */
//method test03() {
//  var p: Ref
//  p := new()
//
//  assert folding acc(Pair(p), write) in acc(Pair(p), write) // ERROR
//}
//
//method test05(p: Ref) {
//  apply folding acc(Pair(p), write) in true --* true // ERROR
//}
