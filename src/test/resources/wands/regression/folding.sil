var f: Int
var g: Int

predicate Pair(this: Ref) {
  acc(this.f, write) && acc(this.g, write)
}

function sum(p: Ref): Int
  requires acc(p.Pair(), write)
{
  unfolding acc(p.Pair(), write) in (p.f) + (p.g)
}

method test06() {
  var p: Ref
  p := new()

  p.g := 0;

  package
    //:: MissingError(wand.not.wellformed:insufficient.permission, /wand-silicon/issue/2/)
    (acc(p.f, write) && p.f > 0)
      --*
    folding acc(p.Pair(), write) in (sum(p) > 0) // rhs is not self-framing
}

method test01() {
  var p: Ref
  p := new()

  p.g := 0;

  package
    (acc(p.f, write) && p.f > 0)
      --*
    folding acc(p.Pair(), write) in (acc(p.Pair(), write) && sum(p) > 0)

  assert acc(p.f, write)
  //:: ExpectedError(assert.failed:insufficient.permission)
  assert acc(p.g, write)
}

method test02()
{
  var p: Ref
  p := new()

  p.g := -1;

  //:: ExpectedError(package.failed:assertion.false)
  package
    (acc(p.f, write) && p.f > 0)
      --*
    folding acc(p.Pair(), write) in (acc(p.Pair(), write) && sum(p) > 0)
}

method test03() {
  var p: Ref
  p := new()

  exhale acc(p.g, 1/2)

  //:: ExpectedError(package.failed:insufficient.permission)
  package
    (acc(p.f, write) && p.f > 0)
      --*
    folding acc(p.Pair(), write) in (acc(p.Pair(), write) && sum(p) > 0)
}

method test04(p: Ref)
  requires (acc(p.f, write) && p.f > 0) --* (acc(p.Pair(), write) && sum(p) > 0)
  requires acc(p.f, write)
{
  p.f := 1
  apply (acc(p.f, write) && p.f > 0) --* (acc(p.Pair(), write) && sum(p) > 0)

  assert acc(p.Pair(), write) && sum(p) > 0
  //:: ExpectedError(assert.failed:insufficient.permission)
  assert acc(p.f, write)
}

method test05() {
  var p: Ref
  p := new()

  p.g := 0;

  package
    (acc(p.f, write) && p.f > 0)
      --*
    folding acc(p.Pair(), write) in (acc(p.Pair(), write) && sum(p) > 0)

  test04(p)

  //:: ExpectedError(assert.failed:wand.not.found)
  assert (acc(p.f, write) && p.f > 0) --* (acc(p.Pair(), write) && sum(p) > 0)
}
