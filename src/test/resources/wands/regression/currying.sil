field f: Int
field g: Int
field h: Int

method nearly_sound_curry(x: Ref)
  requires (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
  ensures acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
{
  inhale acc(x.f, write) && acc(x.g, write) /* inhaling A in applying ... in packaging ... in packaging ... */

  apply (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
  package acc(x.g, write) --* acc(x.h, write)
  package acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
}

method nearly_sound_uncurry(x: Ref)
  requires acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
  ensures (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
{
  inhale acc(x.f, write) && acc(x.g, write) /* inhaling A in applying ... in applying ... in packaging ... */

  apply acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
  apply acc(x.g, write) --* acc(x.h, write)
  package (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
}

method wrong_curry01(x: Ref)
  requires (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
  ensures acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
{
  inhale acc(x.f, write)

  //:: ExpectedOutput(apply.failed:insufficient.permission)
  apply (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
  package acc(x.g, write) --* acc(x.h, write)

  exhale acc(x.f, write)

  package acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
}

method wrong_curry02(x: Ref)
  requires (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
  ensures acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
{
  inhale acc(x.f, write)

  package acc(x.g, write) --* (applying ((acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)) in acc(x.h, write))

  //:: ExpectedOutput(exhale.failed:insufficient.permission)
  exhale acc(x.f, write)

  package acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
}

method uncurry(x: Ref)
  requires acc(x.f, write) --* (acc(x.g, write) --* acc(x.h, write))
  ensures (acc(x.f, write) && acc(x.g, write)) --* acc(x.h, write)
{
  define F acc(x.f, write)
  define G acc(x.g, write)
  define H acc(x.h, write)

  package (F&&G) --* (applying (F--*(G--*H)) in (applying (G--*H) in H))

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false // Never trust a magic wand!
}
