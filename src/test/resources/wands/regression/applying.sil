field f: Int
field g: Int

predicate Pair(this: Ref) {
  acc(this.f, write) && acc(this.g, write)
}

function sum(p: Ref): Int
  requires acc(Pair(p), write)
{
  unfolding acc(Pair(p), write) in (p.f) + (p.g)
}

method test01(p: Ref)
  requires acc(p.f, 1/2) --* (acc(p.f, write) && p.f > 0)
  requires acc(p.f, 1/2)
  requires acc(p.g, write)
{
  p.g := 1;

  // assert applying (acc(p.f, 1/2) --* (acc(p.f, write) && p.f > 0)) in p.f > 0

  package
    (acc(p.g, 1/2) && p.g > 0 && acc(p.f, 1/2)) /* Do we actually need p.g > 0 here? */
      --*
    (applying
      (acc(p.f, 1/2) --* (acc(p.f, write) && p.f > 0))
     in
      (acc(p.f, write) && acc(p.g, write) && ((p.f) + (p.g) > 0)))

  apply
    (acc(p.g, 1/2) && p.g > 0 && acc(p.f, 1/2))
      --*
    (acc(p.f, write) && acc(p.g, write) && ((p.f) + (p.g) > 0))

  fold acc(Pair(p), write)
  assert sum(p) > 0

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}
