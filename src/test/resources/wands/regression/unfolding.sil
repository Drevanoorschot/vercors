field f: Int
field g: Int

predicate Pair(this: Ref) {
  acc(this.f) && acc(this.g)
}

function sum(p: Ref): Int
  requires acc(Pair(p))
{
  unfolding acc(Pair(p)) in (p.f) + (p.g)
}

method test06(p: Ref) {
  package
    //:: ExpectedOutput(wand.not.wellformed)
    (acc(Pair(p)) && sum(p) == 10)
      --*
    unfolding acc(Pair(p)) in p.f + p.g == 10 // rhs is not self-framing
}

method test07(p: Ref) {
  package
    (acc(Pair(p)) && sum(p) == 10)
      --*
    acc(Pair(p)) && unfolding acc(Pair(p)) in p.f + p.g == 10

  inhale acc(Pair(p))
  unfold Pair(p)
  p.f := 5
  p.g := p.f
  fold Pair(p)

  apply acc(Pair(p)) && sum(p) == 10 --* acc(Pair(p)) && unfolding acc(Pair(p)) in p.f + p.g == 10
  assert unfolding acc(Pair(p)) in p.f + p.g == 10

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}

method test01() {
  var p: Ref
  p := new(f, g)

  p.f := 3; p.g := 7
  fold acc(Pair(p))

  package
    (acc(Pair(p)) && sum(p) == 10)
      --*
    unfolding acc(Pair(p)) in acc(p.f) && acc(p.g) && p.f + p.g == 10 // rhs is not self-framing

  apply acc(Pair(p)) && sum(p) == 10 --* acc(p.f) && acc(p.g) && p.f + p.g == 10
  fold acc(Pair(p))
  assert sum(p) == 10

  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}

method test02()
{
  var p: Ref
  p := new(f, g)

  p.g := -1;

  //:: ExpectedOutput(package.failed:assertion.false)
  package
    (acc(p.f) && p.f > 0)
      --*
    folding acc(Pair(p)) in (acc(Pair(p)) && sum(p) > 0)
}

//method test03() {
//  var p: Ref
//  p := new(f, g)
//
//  exhale acc(p.g, 1/2)
//
//  //:: ExpectedOutput(package.failed:insufficient.permission)
//  package
//    (acc(p.f) && p.f > 0)
//      --*
//    folding acc(Pair(p)) in (acc(Pair(p)) && sum(p) > 0)
//}
//
//method test04(p: Ref)
//  requires (acc(p.f) && p.f > 0) --* (acc(Pair(p)) && sum(p) > 0)
//  requires acc(p.f)
//{
//  p.f := 1
//  apply (acc(p.f) && p.f > 0) --* (acc(Pair(p)) && sum(p) > 0)
//
//  assert acc(Pair(p)) && sum(p) > 0
//  //:: ExpectedOutput(assert.failed:insufficient.permission)
//  assert acc(p.f)
//}
//
//method test05() {
//  var p: Ref
//  p := new(f, g)
//
//  p.g := 0;
//
//  package
//    (acc(p.f) && p.f > 0)
//      --*
//    folding acc(Pair(p)) in (acc(Pair(p)) && sum(p) > 0)
//
//  test04(p)
//
//  //:: ExpectedOutput(assert.failed:wand.not.found)
//  assert (acc(p.f) && p.f > 0) --* (acc(Pair(p)) && sum(p) > 0)
//}
