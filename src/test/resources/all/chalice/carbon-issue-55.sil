// chaliceSuite/regressions/internal-bug-10.chalice
domain GlobalKPermission {

  unique function globalK$(): Perm

  axiom globalKReadOnly {
    (globalK$() > none) && (write > globalK$())
  }
}

field old$methodPermission: Perm

field joinable$: Bool

field Nodenext$: Ref

field Nodevalue$: Int

field par$Nodeinit$this$_1: Ref

field par$Nodeinit$k$: Perm

field par$Nodeinit$v: Int

field old$Nodeadd$0: Int

field old$Nodeadd$1: Bool

field par$Nodeadd$this$_2: Ref

field par$Nodeadd$k$_1: Perm

field par$Nodeadd$x: Int

function Nodesize$(this$_3: Ref): Int
  requires this$_3 != null
  requires acc(Nodevalid$(this$_3), wildcard)
  ensures result > 0
{
  (unfolding acc(Nodevalid$(this$_3), wildcard) in (this$_3.Nodenext$ != null ? 1 + Nodesize$(this$_3.Nodenext$) : 1))
}

function Nodecontains$(this$_4: Ref, i: Int): Bool
  requires this$_4 != null
  requires acc(Nodevalid$(this$_4), wildcard)
{
  (unfolding acc(Nodevalid$(this$_4), wildcard) in (i == this$_4.Nodevalue$) || (this$_4.Nodenext$ != null) && Nodecontains$(this$_4.Nodenext$, i))
}

predicate Node$MonitorInvariant(this$: Ref) {
  true
}

predicate Nodevalid$(this$_5: Ref) {
  acc(this$_5.Nodenext$, write) && acc(this$_5.Nodevalue$, write) && ((this$_5.Nodenext$ != null) ==> acc(Nodevalid$(this$_5.Nodenext$), write))
}

method Nodeinit$(this$_1: Ref, k$: Perm, v: Int)
  requires this$_1 != null
  requires k$ > none
  requires write > k$
  requires acc(this$_1.Nodenext$, write) && acc(this$_1.Nodevalue$, write)
  ensures acc(Nodevalid$(this$_1), write) && (Nodesize$(this$_1) == 1) && (forall y: Int :: true ==> (Nodecontains$(this$_1, y) == (y == v)))
{
  var n$: Ref
  var a$: Ref
  var b$: Ref
  var c$: Ref
  this$_1.Nodenext$ := null
  this$_1.Nodevalue$ := v
  fold acc(Nodevalid$(this$_1), write)
}

method Nodeadd$(this$_2: Ref, k$_1: Perm, x: Int)
  requires this$_2 != null
  requires k$_1 > none
  requires write > k$_1
  requires acc(Nodevalid$(this$_2), write)
  ensures acc(Nodevalid$(this$_2), write)
  ensures Nodesize$(this$_2) == old(Nodesize$(this$_2)) + 1
  //:: UnexpectedOutput(postcondition.violated:assertion.false, /Carbon/issue/55/)
  ensures (forall y: Int :: true ==> (Nodecontains$(this$_2, y) == old(Nodecontains$(this$_2, y)) || (x == y)))
{
  var n$_1: Ref
  var a$_1: Ref
  var b$_1: Ref
  var c$_1: Ref
  var n: Ref
  var newK$: Perm
  var newK$_1: Perm
  unfold acc(Nodevalid$(this$_2), write)
  if (this$_2.Nodenext$ == null) {
    n$_1 := new(old$methodPermission, joinable$, Nodenext$, Nodevalue$, par$Nodeinit$this$_1, par$Nodeinit$k$, par$Nodeinit$v, old$Nodeadd$0, old$Nodeadd$1, par$Nodeadd$this$_2, par$Nodeadd$k$_1, par$Nodeadd$x)
    n$_1.Nodenext$ := null
    n$_1.par$Nodeinit$this$_1 := null
    n$_1.par$Nodeadd$this$_2 := null
    n := n$_1
    fresh newK$
    constraining(newK$) {
      Nodeinit$(n, newK$, x)
    }
    this$_2.Nodenext$ := n
  } else {
    fresh newK$_1
    constraining(newK$_1) {
      Nodeadd$(this$_2.Nodenext$, newK$_1, x)
    }
  }
  fold acc(Nodevalid$(this$_2), write)
}
