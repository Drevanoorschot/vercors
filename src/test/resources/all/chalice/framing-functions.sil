  var value: Int
  var next: Ref
  predicate valid(this: Ref) { acc(this.value, write) && acc(this.next, write) && (((this.next) != (null)) ==> acc(this.next.valid, write)) }
  method set(this: Ref, x: Int, y: Int)
    requires acc(this.valid, write)
    ensures acc(this.valid, write)
  {
  }
  function itemAt(this: Ref, i: Int): Int
    requires acc(this.valid, write) && 0 <= i
  { (unfolding acc(this.valid, write) in (((i) == (0)) || ((this.next) == (null)) ? this.value : itemAt(this.next, i - 1))) }
  method M(this: Ref, x: Ref, y: Ref)
    requires ((x) != (null)) && ((y) != (null)) && ((x) != (y)) && acc(x.valid, write) && acc(y.valid, write)
  {
    var i: Int := itemAt(x, 0)
    var j: Int := itemAt(y, 0)
    set(y, 0, 10);
    assert ((i) == (itemAt(x, 0)))
    //:: ExpectedError(assert.failed:assertion.false)
    assert ((j) == (itemAt(y, 0)))
  }
