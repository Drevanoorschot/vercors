domain GlobalKPermission {

  unique function globalK$(): Perm

  axiom globalKReadOnly {
    (globalK$() > none) && (write > globalK$())
  }
}

field old$methodPermission: Perm

field joinable$: Bool

field Celltk$: Ref

field par$Cellnoop$this$_1: Ref

field par$Cellnoop$k$: Perm

field par$Celltest$this$_3: Ref

field par$Celltest$k$_1: Perm

field par$Celltest$a: Int

function Cellget1$(this$_2: Ref): Ref
  requires this$_2 != null
  requires acc(this$_2.Celltk$, wildcard)
{
  this$_2.Celltk$
}

predicate Cell$MonitorInvariant(this$: Ref) {
  true
}

method Cellnoop$(this$_1: Ref, k$: Perm)
  requires this$_1 != null
  requires k$ > none
  requires write > k$
{
  var n$: Ref
  var a$: Ref
  var b$: Ref
  var c$: Ref

}

method Celltest$(this$_3: Ref, k$_1: Perm, a: Int)
  requires this$_3 != null
  requires k$_1 > none
  requires write > k$_1
  requires acc(this$_3.Celltk$, write)
  ensures acc(this$_3.Celltk$, write)
{
  var n$_1: Ref
  var a$_1: Ref
  var b$_1: Ref
  var c$_1: Ref
  var newK$: Perm
  var tk: Ref
  fresh newK$
  constraining(newK$) {
    tk := new(old$methodPermission, joinable$, Celltk$, par$Cellnoop$this$_1, par$Cellnoop$k$, par$Celltest$this$_3, par$Celltest$k$_1, par$Celltest$a)
    tk.Celltk$ := null
    tk.par$Cellnoop$this$_1 := null
    tk.par$Celltest$this$_3 := null
    tk.joinable$ := true
    tk.old$methodPermission := newK$
    tk.par$Cellnoop$this$_1 := this$_3
    tk.par$Cellnoop$k$ := newK$
    exhale true && (this$_3 != null) && (newK$ > none) && (write > newK$)
  }
  this$_3.Celltk$ := tk
  assert Cellget1$(this$_3).joinable$
  inhale true
  assert Cellget1$(this$_3) == tk
  //:: UnexpectedOutput(assignment.failed:insufficient.permission, /Carbon/issue/50/)
  Cellget1$(this$_3).joinable$ := false
}
