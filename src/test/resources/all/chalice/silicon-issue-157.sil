// chaliceSuite/regressions/internal-bug-11.chalice
domain GlobalKPermission {

  unique function globalK$(): Perm

  axiom globalKReadOnly {
    (globalK$() > none) && (write > globalK$())
  }
}

field old$methodPermission: Perm

field joinable$: Bool

field Testx$: Int

field Testtk$: Ref

field par$Testfoo$this$_2: Ref

field par$Testfoo$k$: Perm

field par$TestjoinTk$this$_3: Ref

field par$TestjoinTk$k$_1: Perm

field par$Testtest$this$_4: Ref

field par$Testtest$k$_2: Perm

predicate Test$MonitorInvariant(this$: Ref) {
  true
}

predicate TestV$(this$_1: Ref) {
  acc(this$_1.Testx$, write)
}

method Testfoo$(this$_2: Ref, k$: Perm)
  requires this$_2 != null
  requires k$ > none
  requires write > k$
  requires acc(TestV$(this$_2), write)
  ensures acc(TestV$(this$_2), write)
{
  var n$: Ref
  var a$: Ref
  var b$: Ref
  var c$: Ref
  unfold acc(TestV$(this$_2), write)
  this$_2.Testx$ := this$_2.Testx$ + 1
  fold acc(TestV$(this$_2), write)
}

method TestBug(this$_3: Ref, k$_1: Perm)
  requires acc(this$_3.Testtk$, write) && (this$_3.Testtk$ != null) && acc(this$_3.Testtk$.joinable$, write) && this$_3.Testtk$.joinable$
{
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}

method TestBug1(this$_3: Ref, k$_1: Perm)
  requires acc(this$_3.Testtk$, write) && (this$_3.Testtk$ != null)
  requires acc(this$_3.Testtk$.joinable$, write) && this$_3.Testtk$.joinable$
{
  //:: ExpectedOutput(assert.failed:assertion.false)
  assert false
}

method TestjoinTk$(this$_3: Ref, k$_1: Perm)
  requires this$_3 != null
  requires k$_1 > none
  requires write > k$_1
  requires acc(this$_3.Testtk$, write) && (this$_3.Testtk$ != null) && acc(this$_3.Testtk$.joinable$, write) && this$_3.Testtk$.joinable$
  ensures acc(TestV$(this$_3), write)
{
  var n$_1: Ref
  var a$_1: Ref
  var b$_1: Ref
  var c$_1: Ref
  assert this$_3.Testtk$.joinable$
  //:: ExpectedOutput(inhale.failed:insufficient.permission)
  inhale true && acc(TestV$(this$_3.Testtk$.par$Testfoo$this$_2), write)
  this$_3.Testtk$.joinable$ := false
  assert acc(TestV$(this$_3), write)
}

method Testtest$(this$_4: Ref, k$_2: Perm)
  requires this$_4 != null
  requires k$_2 > none
  requires write > k$_2
  requires acc(this$_4.Testx$, write) && (this$_4.Testx$ == 0)
  requires acc(this$_4.Testtk$, write)
{
  var n$_2: Ref
  var a$_2: Ref
  var b$_2: Ref
  var c$_2: Ref
  var newK$: Perm
  var tklocal: Ref
  var newK$_1: Perm
  fold acc(TestV$(this$_4), write)
  fresh newK$
  constraining(newK$) {
    tklocal := new(old$methodPermission, joinable$, Testx$, Testtk$, par$Testfoo$this$_2, par$Testfoo$k$, par$TestjoinTk$this$_3, par$TestjoinTk$k$_1, par$Testtest$this$_4, par$Testtest$k$_2)
    tklocal.Testtk$ := null
    tklocal.par$Testfoo$this$_2 := null
    tklocal.par$TestjoinTk$this$_3 := null
    tklocal.par$Testtest$this$_4 := null
    tklocal.joinable$ := true
    tklocal.old$methodPermission := newK$
    tklocal.par$Testfoo$this$_2 := this$_4
    tklocal.par$Testfoo$k$ := newK$
    exhale true && (this$_4 != null) && (newK$ > none) && (write > newK$) && acc(TestV$(this$_4), write)
  }
  this$_4.Testtk$ := tklocal
  fresh newK$_1
  constraining(newK$_1) {
    TestjoinTk$(this$_4, newK$_1)
  }
}
