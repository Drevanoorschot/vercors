var value: Int

var array: Seq[Ref]

method init(this:Ref, i:Int)
requires acc(this.array, write)
ensures acc(this.array, wildcard)
ensures |this.array| == i
ensures forall k:Int :: k in [0..i) ==> acc(this.array[k].value, write)
{
    inhale |this.array| == i && forall k:Int :: k in [0..i) ==> acc(this.array[k].value, write)
}

method set(this:Ref, i:Int, val:Int)
requires acc(this.array, wildcard)  // Yannis: changed permission to wildcard
requires 0 <= i && i < |this.array|
// TODO: change this syntax to acc(this.array[i].value, write)  // Yannis: this does not work.  Apparently, the exhaling of line 21 insists on finding a quantified heap chunk
// Korbinian: Added a issue here: https://bitbucket.org/mschwerhoff/silicon_ccproto/issue/1/allow-syntax-acc-s-i-f-write-instead-of
requires forall k:Int :: k in [i..i+1) ==> acc(this.array[k].value, write)
ensures acc(this.array, wildcard)
ensures forall k:Int :: k in [i..i+1) ==> acc(this.array[k].value, write)
ensures 0 <= i && i < |this.array|
ensures this.array[i].value == val
{
    this.array[i].value := val
}

function get(this:Ref, i:Int):Int
requires acc(this.array, wildcard)
requires 0 <= i && i < |this.array|
requires acc(this.array[i].value, wildcard)  // Yannis: changed the spec into a more elegant one.  Still works
{
    this.array[i].value
}

method caller()
{
    var mutableArray:Ref
    mutableArray := new()
    init(mutableArray, 5)
    set(mutableArray, 0, 2)
    assert get(mutableArray, 0) == 2
}

// TODO: wildcard issues!
/*method set(this:Ref, i:Int, val:Int)
requires acc(this.array, wildcard)
requires 0 <= i && i < |this.array|
requires forall j:Int :: j >= i && j < i+1 ==> acc(this.array[j].value, write)
ensures acc(this.array, wildcard)
ensures forall k:Int :: k >= i && k < i+1 ==> acc(this.array[k].value, write)
ensures this.array[i].value == val
{
    this.array[i].value := val
}*/


