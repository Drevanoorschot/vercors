var value:Int

// this does not even need permissions
method parallel_max2(i:Seq[Int], start:Int, end:Int) returns (mx:Int)
  requires 0 <= start && start < end && end <= |i|
  ensures (forall index: Int :: start <= index && index < end ==> i[index] <= mx)   // Yannis: added specs to make it interesting
{
    var middle:Int
    var ml:Int
    var mr:Int

    if(end-start > 1)
    {
        middle := start + (end-start) \ 2
        ml := parallel_max2(i, start, middle)
        mr := parallel_max2(i, middle, end)
        mx := ml > mr ? ml : mr
    } else {
        mx := i[start]  // Yannis: old line was incorrect:   mx := i[middle]
    }
}

// Yannis: I am not sure what the point of this example is.  There are no permissions here