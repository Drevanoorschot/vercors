// class "Node"
var value: Int
var left: Ref
var right: Ref
var parent: Ref
var parentStruct: Ref /* pointer to the node's composite */

// class "Composite"
var all: Set[Ref]


predicate inv(this: Ref)
{
     acc(this.all, write)
     && !(null in (this.all))
     && (forall m: Ref :: m in (this.all) ==> acc(m.parent, wildcard))
     && (forall o: Ref :: (o in (this.all) && o.parent!= null) ==> acc(o.parentStruct, wildcard))
     && (forall q: Ref :: q in (this.all) ==> acc(q.left, 1/2))
}


function valid(this: Ref) : Bool
  requires acc(this.parentStruct, wildcard) && this.parentStruct!=null && acc(inv(this.parentStruct), wildcard)
{
  unfolding acc(inv(this.parentStruct), wildcard) in (this in (this.parentStruct.all))
}

function getLeft(this: Ref) : Ref
  requires acc(this.parentStruct, wildcard) && this.parentStruct!=null && acc(inv(this.parentStruct), wildcard) && valid(this)
{
  unfolding acc(inv(this.parentStruct), wildcard) in this.left
}


