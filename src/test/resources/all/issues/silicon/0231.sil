predicate P(r: Ref)

method test01(this: Ref)
  requires acc(P(this));
{
  exhale perm(P(this)) == write &&
         acc(P(this)) &&
         perm(P(this)) == none
}

method test02a(this: Ref)
  requires acc(P(this));
{
  //:: ExpectedOutput(exhale.failed:assertion.false)
  exhale (forperm[P] r :: false) &&
         acc(P(this)) &&
         (forperm[P] r :: false)
}

method test02b(this: Ref)
  requires acc(P(this));
{
  exhale /*(forperm[P] r :: false &&)*/
         acc(P(this)) &&
         (forperm[P] r :: false)
}


method test03a(this: Ref)
{
  while (true)
    invariant [acc(P(this), write), true]
    invariant [true, (perm(P(this)) > none) ==> acc(P(this))]
    //:: UnexpectedOutput(invariant.not.preserved:insufficient.permission, /Silicon/issue/231/)
    invariant [true, (perm(P(this)) >= write) ==> acc(P(this))]
  {
    //exhale acc(P(this))
  }
}


method test03b(this: Ref)
{
  while (true)
    invariant [acc(P(this), write), true]
    invariant [true, (perm(P(this)) > none) ==> acc(P(this))]
    invariant [true, (perm(P(this)) >= write) ==> acc(P(this))]
  {
    exhale acc(P(this))
  }
}
