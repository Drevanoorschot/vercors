var item: Int
var next: Ref

predicate valid(this: Ref) {
     acc(this.item, write)
  && acc(this.next, write)
  && (this.next != null ==> acc(this.next.valid, write))
}

function size(this: Ref): Int
  requires this != null
  requires acc(this.valid, write)
  ensures result >= 1
{ unfolding acc(this.valid, write) in (this.next == null ? 1 : 1 + size(this.next)) }

method unrollStatement(this: Ref)
  requires this != null
  requires acc(this.valid, write)
  requires size(this) == 2
{
  unfold acc(this.valid, write)
  unfold acc(this.next.valid, write)

  //:: UnexpectedError(assert.failed:assertion.false, /silicon/issue/33/)
  assert this.next.next == null
}




function size_0(this: Ref): Int
  requires this != null
  requires acc(this.valid, write)
  //:: UnexpectedError(postcondition.violated:assertion.false, /silicon/issue/33/)
  ensures result >= 1
{
  unfolding acc(this.valid, write) in (
    this.next == null
      ? 1
      : unfolding acc(this.next.valid, write) in (this.next.next == null ? 2 : 2 + size_0(this.next.next)))
}

method unrollExpression(this: Ref)
  requires this != null
  requires acc(this.valid, write)
  requires size_0(this) == 2
{
  //:: UnexpectedError(assert.failed:assertion.false, /silicon/issue/33/)
  assert
    unfolding acc(this.valid, write) in
      unfolding acc(this.next.valid, write) in
        this.next.next == null
}