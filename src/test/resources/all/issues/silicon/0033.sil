//var item: Int
var next: Ref

predicate valid(this: Ref) {
//     acc(this.item, write)
     acc(this.next, write)
  && (this.next != null ==> acc(this.next.valid(), write))
}

function size(this: Ref): Int
  requires this != null
  requires acc(this.valid(), write)
  ensures result >= 1
{ unfolding acc(this.valid(), write) in (this.next == null ? 1 : 1 + size(this.next)) }

method unfoldOnce(this: Ref)
  requires this != null
  requires acc(this.valid(), write)
  requires size(this) == 1
{
  unfold acc(this.valid(), write)

  assert this.next == null

  //:: ExpectedError(assert.failed:assertion.false)
  assert this.next != null
}

method unfoldTwice(this: Ref)
  requires this != null
  requires acc(this.valid(), write)
  requires size(this) == 2
{
  unfold acc(this.valid(), write)

  assert size(this.next) == 1
    /* Required by Silicon, the final assertions fails otherwise.
     * Alternatively, run Silicon with --unrollFunctions=2.
     * See also Silicon issue #41.
     */

  unfold acc(this.next.valid(), write)

  assert this.next.next == null
}

function size_0(this: Ref): Int
  requires this != null
  requires acc(this.valid(), write)
  ensures result >= 1
{
  unfolding acc(this.valid(), write) in (
    this.next == null
      ? 1
      : unfolding acc(this.next.valid(), write) in (this.next.next == null ? 2 : 2 + size_0(this.next.next)))
}

method unrollExpression(this: Ref)
  requires this != null
  requires acc(this.valid(), write)
  requires size_0(this) == 2
{
  assert
    unfolding acc(this.valid(), write) in
      unfolding acc(this.next.valid(), write) in
        this.next.next == null
}
