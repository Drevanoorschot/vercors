// test aliasing information of newly created objects
method t1(this: Ref, a: Int, b: Bool, g: Ref) returns (c: Bool, d: Int)
    requires b && acc(this.value, write)
    ensures (d == 1) || (d == 2)
{
    var e: Int
    var f1: Ref
    var f2: Ref
    this.value := 1
    f1 := new()
    f2 := new()
    if (g != null) {
        exhale g != f1
    }
    exhale this.value <= 42
    exhale f1 != f2
    inhale (a == -11)
    exhale a < 0
    d := 2
    if (b) {
        d := 1
    } else {
        d := 3
    }
}

var value: Int

// test aliasing information of newly created objects
method t2(a: Ref, b: Ref) returns ()
{
    var l1: Ref
    var l2: Ref
    l1 := new()
    l2 := new()
    exhale a != l1
    exhale l1 != l2
    //:: ExpectedError(assertion.false)
    exhale a != b
}

// test aliasing information of parameters 1
method t3(a: Ref, b: Ref) returns ()
{
    if (a == null) {
        if (b != null) {
            exhale a != b
        }
        //:: ExpectedError(assertion.false)
        exhale a != b
    }
}

// test aliasing information of parameters 2
method t4(a: Ref, b: Ref) returns ()
{
    if (a == null) {
        if (b != null) {
            exhale a != b
        }
    }
}

/* test aliasing information between newly created objects and objects that already exist but are
 * "hidden" in predicates.
 */

var Node_v: Int
var Node_n: Ref

predicate Node_P(this: Ref) {
     acc(this.Node_v, wildcard)
  && acc(this.Node_n, wildcard)
  && (this.Node_n != null ==> acc(this.Node_n.Node_P(), wildcard))
}

method test5(n: Ref)
  requires n != null && acc(n.Node_P(), wildcard)
{
  var m: Ref

  m := new()
  assert m != n

  unfold acc(n.Node_P(), wildcard)
  if (n.Node_n != null) {
    //:: UnexpectedError(assert.failed:assertion.false, /silicon/issue/29/)
    assert m != (n.Node_n)

    unfold acc(n.Node_P(), wildcard)
    //:: ExpectedError(insufficient.permission)
    //:: MissingError(insufficient.permission, /silicon/issue/34/)
    if (n.Node_n.Node_n != null) {
      assert m != (n.Node_n.Node_n)
    }
  }
}
