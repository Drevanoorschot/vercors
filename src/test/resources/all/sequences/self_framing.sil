//:: IgnoreFile(/silicon/issue/40/)
// TODO: create issue for this problem
// Korbinian(3/2/2014): These are interesting examples
// The third one does not work, because of issue https://bitbucket.org/mschwerhoff/silicon_ccproto/issue/1/allow-syntax-acc-s-i-f-write-instead-of
// I added a equivalent formulation

var f:Int

// Yannis: the following precondition should be rejected, as non-self-framing
method foo(s: Seq[Ref])
  requires |s| > 2 && (forall i: Int :: i in [0..2) ==> acc(s[i].f, write))
{
    //:: ExpectedOutput(inhale.failed:receiver.null)
    inhale |s| > 3 ==> s[2].f == 1
}


// Yannis: same, but should be accepted
method foo1(s: Seq[Ref])
  requires |s| > 2 && (forall i1: Int :: i1 in [0..2) ==> acc(s[i1].f, write))
  requires s[0].f == 1
{}

// Yannis: same, should be accepted
method foo2(s: Seq[Ref])
  requires |s| > 2 && acc(s[0].f, write) && acc(s[1].f, write)
{
    inhale forall i2: Int :: i2 in [0..2) ==> s[i2].f == 0
}

method foo2korbinian(s:Seq[Ref])
requires |s| > 2
requires forall i:Int :: i in [0..1) ==> acc(s[i].f, write)
requires forall i:Int :: i in [1..2) ==> acc(s[i].f, write)
requires forall i:Int :: i in [0..2) ==> s[i].f == 0
{}

// Yannis: same, should be rejected
method foo3(s: Seq[Ref])
  requires |s| > 2 && acc(s[0].f, write) && acc(s[1].f, write)
  requires forall i3: Int :: i3 in [0..|s|) ==> s[i3] != null
{
  //:: ExpectedOutput(inhale.failed:insufficient.permission)
  inhale (forall i3: Int :: i3 in [0..|s|) ==> s[i3].f == 0)
}