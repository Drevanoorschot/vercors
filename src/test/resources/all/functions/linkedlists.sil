field next: Ref
field val: Int

predicate list(xs: Ref) {
  acc(xs.next) && acc(xs.val) && (xs.next != null ==> acc(list(xs.next)))
}

function length(xs: Ref): Int
  requires acc(list(xs))
  ensures result > 0
{ unfolding acc(list(xs)) in 1 + (xs.next == null ? 0 : length(xs.next)) }

function sum(xs: Ref): Int
  requires acc(list(xs))
{ unfolding acc(list(xs)) in xs.val + (xs.next == null ? 0 : sum(xs.next)) }

function head(xs: Ref): Int
  requires acc(list(xs))
{ unfolding acc(list(xs)) in xs.val }

function tail(xs: Ref): Ref
  requires acc(list(xs))
{ unfolding acc(list(xs)) in xs.next }

function last(xs: Ref): Int
  requires acc(list(xs))
{ unfolding acc(list(xs)) in xs.next == null ? xs.val : last(xs.next) }

function contains(xs: Ref, x: Int): Bool
  requires acc(list(xs))
{ unfolding acc(list(xs)) in x == xs.val || (xs.next != null && contains(xs.next, x)) }

function elems(xs: Ref): Seq[Int]
  requires acc(list(xs))
{ unfolding acc(list(xs)) in Seq(xs.val) ++ (xs.next == null ? Seq[Int]() : elems(xs.next)) }

function get(xs: Ref, index: Int): Int
  requires acc(list(xs))
  requires 0 <= index && index < length(xs)
{ unfolding acc(list(xs)) in index == 0 ? xs.val : get(xs.next, index - 1) }

method prepend(xs: Ref, y: Int) returns (ys: Ref)
  requires acc(list(xs))
  ensures acc(list(ys))
  //:: UnexpectedOutput(postcondition.violated:assertion.false, /silicon/issue/130/)
  //:: UnexpectedOutput(postcondition.violated:assertion.false, /carbon/issue/29/)
  ensures length(ys) == old(length(xs)) + 1
  ensures elems(ys) == Seq(y) ++ old(elems(xs))
  ensures old(y <= head(xs) && ascending(xs)) ==> ascending(ys)
{
  ys := new(val, next)
  ys.val := y
  ys.next := xs
  fold acc(list(ys))
}

method append(xs: Ref, y: Int)
  requires acc(list(xs))
  ensures acc(list(xs))
  ensures length(xs) == old(length(xs)) + 1
  ensures elems(xs) == old(elems(xs)) ++ Seq(y)
  ensures old(y >= last(xs) && ascending(xs)) ==> ascending(xs)
{
  unfold acc(list(xs))

  if (xs.next == null) {
    var ys: Ref
    ys := new(val, next)
    ys.val := y
    ys.next := null
    fold acc(list(ys))
    xs.next := ys

    assert length(ys) == 1     // TODO: Should not be necessary
    assert elems(ys) == Seq(y) // TODO: Should not be necessary
    assert ascending(ys)       // TODO: Should not be necessary
  } else {
    append(xs.next, y)

    assert head(xs.next) == elems(xs.next)[0] // TODO: Should not be necessary
  }

  fold acc(list(xs))
}

function ascending(xs: Ref): Bool
  requires acc(list(xs))
{ unfolding acc(list(xs)) in (xs.next == null || (xs.val <= head(xs.next) && ascending(xs.next))) }

method insert(xs: Ref, y: Int) returns (ys: Ref, i: Int)
  requires acc(list(xs))
  ensures acc(list(ys))
  ensures 0 <= i && i <= old(length(xs))
  //:: UnexpectedOutput(postcondition.violated:assertion.false, /silicon/issue/130/)
  //:: UnexpectedOutput(postcondition.violated:assertion.false, /carbon/issue/29/)
  ensures length(ys) == old(length(xs)) + 1
  ensures elems(ys) == old(elems(xs))[0..i] ++ Seq(y) ++ old(elems(xs))[i..]
  ensures old(ascending(xs)) ==> ascending(ys)
{
  if (y <= head(xs)) {
    ys := prepend(xs, y)
    i := 0
  } elsif (tail(xs) == null) {
    append(xs, y)
    ys := xs
    i := 1
  } else {
    unfold acc(list(xs))

    if (y <= unfolding acc(list(xs.next)) in xs.next.val) {
      ys := new(val, next)
      ys.val := y
      ys.next := xs.next
      fold acc(list(ys))
      assert length(ys) == old(length(xs)) // TODO: Should not be necessary
      assert elems(ys) == Seq(y) ++  unfolding acc(list(ys)) in elems(xs.next) // TODO: Should not be necessary
      assert old(ascending(xs)) ==> ascending(ys) // TODO: Should not be necessary
      xs.next := ys
      ys := xs
      i := 1
    } else {
      ys, i := insert(xs.next, y)
      assert head(ys) == elems(ys)[0] // TODO: Should not be necessary
      xs.next := ys
      ys := xs
      i := i + 1
    }

    fold acc(list(ys))
  }
}

/* Misc */

/* At some point, Silicon had a small bug in the handling of disjunction, as used
 * in the body of ascending(xs). Hence this test.
 */
method test01(xs: Ref)
  requires acc(list(xs)) && ascending(xs)
{
  unfold acc(list(xs))
  assume xs.next != null

  assert ascending(xs.next)
}

/* Modelled after a Chalice2Silver test case, uncovered a problem in Silicon */
method test02(xs: Ref, x: Int, ys: Ref)
  requires ys != null
  requires acc(list(ys))
  requires acc(xs.val) && acc(xs.next)
{
  xs.val := x
  xs.next := ys
  
  fold acc(list(xs))
  
  assert forall i: Int :: i in [1..length(xs)) ==> get(xs, i) == unfolding acc(list(xs), write) in get(ys, i - 1)
}
