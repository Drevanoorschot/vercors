var f:Int

/*method bfind (S: Seq[Ref], x:Int, p: Perm) returns (index:Int)
  requires p > none && p < write
  requires forall i:Int :: i in [0..|S|)  ==> acc(S[i].f, p)
  requires forall i1:Int :: i1 in [0..|S|-1)  ==> S[i1].f < S[i1+1].f
  ensures forall i2:Int :: i2 in [0..|S|) ==> acc(S[i2].f, p)
  ensures -1 <= index && index < |S|
  ensures 0 <= index && index < |S| ==> S[index].f==x
  ensures index == -1 ==> (forall i3:Int :: i3 in [0..|S|) ==> S[i3].f != x)
{
    if(|S| == 0) {
        index := -1
    }
    elsif (|S|==1) {
        index := x == S[0].f ? 0 : -1
    }
    else {
        // split
        var k:Int
        inhale 0<k && k<|S|-1
		
		if (S[k].f < x) { index := bfind(S[0..k], x, p) } // Silicon reports: precondition does not hold!  not enough permissions
		else { index := bfind(S[k..|S|], x, p) }
    }
}*/

method bfind(S: Seq[Ref], start: Int, end: Int, x:Int, p: Perm) returns (index:Int)
  requires p > none && p < write && start <= end
  requires forall i:Int :: i in [start..end) ==> acc(S[i].f, p)
  requires forall i1:Int :: start<=i1 && i1<end-1 ==> S[i1].f<S[i1+1].f  // Silicon reports no self-framing!  not enough permissions for S[i1].f
  ensures forall i2:Int :: i2 in [start..end) ==> acc(S[i2].f, p)
  ensures (start <= index && index < end) || index == -1
  ensures start <= index && index < end ==> S[index].f==x
  ensures index == -1 ==> (forall i3:Int :: i3 in [start..end) ==> S[i3].f != x)
{
    if(|S| == 0) {
        index := -1
    }
    elsif (|S|==1) {
        index := x == S[0].f ? 0 : -1
    }
    else {
        // split
        var k:Int
        inhale 0<k && k<|S|-1
		
		if (S[k].f < x) { index := bfind(S, 0, k, x, p) }
		else { index := bfind(S, k, |S|, x, p) }
    }
}