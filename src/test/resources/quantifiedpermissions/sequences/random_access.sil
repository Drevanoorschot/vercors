field f: Int

method test06(s: Seq[Ref], a: Int, b: Int, n: Int)
  requires 0 <= a && 0 <= b && 0 <= n
  requires a + n * b <= |s|
{
  var j: Int := 0

  inhale 0 <= j && j <= n
  inhale forall i: Int :: i in [0..n) ==> acc(s[a + i*b].f)
    /* Yields the non-null axiom
        (assert (forall ((i Int)) (!
          (implies
            ($Seq.in ($Seq.rng 0 n) i)
            (not (= ($Seq.at s (+ a (* i b))) $Ref.null)))
          :pattern (($Seq.in ($Seq.rng 0 n) i))
        )))
     */

  /* TODO: Fails because ($Seq.at s (+ a (* i b))) doesn't trigger above axiom */
  assert s[a + j*b] != null
}

method test07(s: Seq[Ref], a: Int, b: Int, n: Int)
  requires 0 <= a && 0 < b && 0 <= n
  requires a + n * b <= |s|
{
  var j: Int := 0
  inhale 0 <= j && j < n
  inhale j % b == a

  inhale forall i: Int :: i in [0..|s|) && i % b == a ==> acc(s[i].f)
    /* Yields the non-null axiom
        (assert (forall ((i Int)) (!
          (implies
            (and
              ($Seq.in ($Seq.rng 0 ($Seq.len s)) i)
              (= (mod i b) a)
            )
            (not (= ($Seq.at s i) $Ref.null)))
          :pattern (($Seq.in ($Seq.rng 0 ($Seq.len s)) i))
          :pattern (($Seq.at s i))
        )))
     */

  /* Verifies because the axiom is triggered */
  assert s[a + j*b] != null
}

method test08(s: Seq[Ref], a: Int, b: Int)
  requires 0 <= a && 0 < b
  requires forall i: Int :: i in [a..|s|) && (i - a) % b == 0 ==> acc(s[i].f)
{
  var j: Int := a

  while (j < |s|)
    invariant a <= j
    invariant (j - a) % b == 0
    invariant forall i: Int :: i in [a..|s|) && (i - a) % b == 0 ==> acc(s[i].f)
  {
    assert j in [a..|s|)
    assert (j - a) % b == 0

    s[j].f := j
    j := j + b

    assume (j - a) % b == 0 // Cannot be proven, but is correct
  }
}

//method test09(s: Seq[Ref], a: Int, b: Int, n: Int)
//  requires 0 <= a && 0 < b && 0 <= n
//  requires a < b
//  requires a + n * b < |s|
//  requires forall i: Int :: i in [0..|s|) && i % b == a ==> acc(s[i].f)
//{
//  var j: Int := a
////  inhale a < b
//
////  while (j < n)
//////    invariant 0 <= j && j <= n
//////    invariant forall i: Int :: i in [0..n) ==> acc(s[a + i*b].f)
//////    invariant forall i: Int :: i in [0..j) ==> s[a + i*b].f == j
////  {
//    inhale forall i: Int :: i in [0..|s|) && i % b == a ==> acc(s[i].f)
////    inhale forall i: Int :: i in [0..j) ==> s[a + i*b].f == j
//    assert j in [0..|s|)
//    assert j % b == a
//
//    s[j].f := j
//    j := j + b
////
////    exhale 0 <= j && j <= n
////    exhale forall i: Int :: i in [0..n) ==> acc(s[a + i*b].f)
////    exhale forall i: Int :: i in [0..j) ==> s[a + i*b].f == j
////  }
//}
