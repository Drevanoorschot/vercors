var left: Ref
var all: Set[Ref]

predicate inv(this: Ref)
{
    this!=null && acc(this.all) && (forall q: Ref :: q in (this.all) ==> acc(q.left, 1/2)) && (forall s: Ref :: (s in (this.all) && s.left == null) ==> acc(s.left, 1/2))
}

method foo() {
  var x: Ref
  var t: Ref
  inhale acc(x.left, write) && x.left == null
  inhale acc(t.all, write) && t.all == Set(x)
  
  //:: UnexpectedOutput(fold.failed:insufficient.permission, /silicon/issue/78/)
  fold acc(inv(t), write)
}
