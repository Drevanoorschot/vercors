var fld: Int
var col: Set[Ref]

predicate inv(collection: Set[Ref]) {
  (forall x: Ref :: x in collection ==> acc(x.fld, write))
}

function getField(this: Ref) : Int
  requires this != null && acc(this.col, write) && acc(inv(this.col), write) && this in this.col
{
  unfolding acc(inv(this.col), write) in this.fld
}

method foo(this: Ref)
  requires this != null && acc(this.col, write) && acc(inv(this.col), write) && this in this.col
  requires getField(this) == 5
{
  unfold acc(inv(this.col), write)
  // :: UnexpectedOutput(assert.failed:assertion.false, /silicon/issue/79/)
  assert this.fld == 5
}

method test(x: Ref, xs: Set[Ref])
  requires forall y: Ref :: y in xs ==> acc(y.fld)
  requires x in xs
  requires x.fld == 0
{
  fold inv(xs)
  unfold inv(xs)
  assert x.fld == 0
}