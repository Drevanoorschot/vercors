field n: Set[Ref]
field f: Int

predicate inv(this: Ref) {
	acc(this.n) && forall x: Ref :: x in this.n ==> acc(x.f)
}

method m1(this: Ref)
  requires acc(inv(this))
  ensures acc(inv(this))
{
	unfold acc(inv(this))

	var t: Ref
	assume t in this.n

	var a: Int := t.f

	fold acc(inv(this))
	unfold acc(inv(this))

	// :: UnexpectedOutput(assert.failed:assertion.false, /silicon/issue/79/)
	assert a == t.f

	fold acc(inv(this))
}
