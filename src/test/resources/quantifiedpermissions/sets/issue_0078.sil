field p: Ref
field s: Set[Ref]

predicate A(this: Ref) {
  acc(this.p)
}

predicate B(this: Ref) {
  acc(this.p, 1/2) && (this.p == null ==> acc(this.p, 1/2))
}

predicate C(this: Ref) {
  acc(this.s) && (forall x: Ref :: x in this.s ==> acc(x.p))
}

predicate D(this: Ref) {
  acc(this.s) && (forall x: Ref :: x in this.s ==> acc(x.p, 1/2)) && (forall x: Ref :: x in this.s && x.p==null ==> acc(x.p, 1/2))
}

method Am(this: Ref)
  requires this != null && acc(this.p) && acc(this.s) && this.s == Set(this) && this.p == null
{
  fold A(this)
}

method Bm(this: Ref)
  requires this != null && acc(this.p) && acc(this.s) && this.s == Set(this) && this.p == null
{
  fold B(this)
}

method Cm(this: Ref)
  requires this != null && acc(this.p) && acc(this.s) && this.s == Set(this) && this.p == null
{
  fold C(this)
}

method Dm(this: Ref)
  requires this != null && acc(this.p) && acc(this.s) && this.s == Set(this) && this.p == null
{
  //:: UnexpectedOutput(fold.failed:insufficient.permission, /silicon/issue/79/)
  fold D(this)
}

method Dmm(this: Ref)
  requires this != null && acc(this.p) && acc(this.s) && this.s == Set(this) && this.p == null
{
  //:: UnexpectedOutput(assert.failed:insufficient.permission, /silicon/issue/79/)
  assert acc(this.s) && (forall x: Ref :: x in this.s ==> acc(x.p, 1/2)) && (forall x: Ref :: x in this.s && x.p==null ==> acc(x.p, 1/2))
}