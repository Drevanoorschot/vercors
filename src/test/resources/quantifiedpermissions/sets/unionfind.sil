// class Node
var struct: Ref
var parent: Ref

function valid(this:Ref) : Bool
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), wildcard)
{
  unfolding acc(inv(this.struct), wildcard) in this in this.struct.nodes
}

function find(this:Ref) : Ref
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), wildcard)
  requires valid(this)
  ensures result != null && result in allNodes(this.struct)
{
    (unfolding acc(inv(this.struct), wildcard) in (this == this.parent)) ? this : (unfolding acc(inv(this.struct), wildcard) in find(this.parent))
}

// missing: proof that find terminates

method add(this: Ref, struct: Ref)
  requires acc(this.struct, write)
  requires acc(this.parent, write)
  requires acc(inv(struct), write)
  requires this.parent == null
  ensures acc(this.struct, wildcard)
  ensures this.struct == struct
  ensures acc(inv(this.struct), write)
  ensures valid(this)
  ensures allNodes(struct) == old(allNodes(struct)) union Set(this)
  ensures this == find(this)
  ensures (forall o: Ref :: o in old(allNodes(struct)) ==> (unfolding acc(inv(struct), wildcard) in find(o)) == old(unfolding acc(inv(struct), wildcard) in find(o)))
{
    this.struct := struct
    this.parent := this

    unfold acc(inv(struct), write)
    struct.nodes := (struct.nodes union Set(this))
    fold acc(inv(struct), write)
	
	//:: UnexpectedOutput(assert.failed:assertion.false, /silicon/issue/79/)
	assert unfolding acc(inv(struct), write) in this.parent == this
}

method lemma0(p: Ref, q: Ref)
  requires acc(q.struct, wildcard) && acc(inv(q.struct), wildcard) && valid(q) && p == find(q)
  ensures acc(q.struct, wildcard)
  ensures acc(p.struct, wildcard)
  ensures p.struct == q.struct
  ensures acc(inv(p.struct), wildcard)
{
  if (p!=q) {
    unfold acc(inv(q.struct), wildcard)
    assert valid(q.parent)
    assert find(q.parent) == find(q)
    lemma0(p, q.parent)
    fold acc(inv(p.struct), wildcard)
  }
}

// prove termination of lemma0

/*method unionn(this: Ref, other: Ref)
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), write)
  requires valid(this)
  requires acc(other.struct, wildcard)
  requires (this.struct) == (other.struct)
  requires valid(other)
  ensures acc(this.struct, wildcard)
  ensures acc(inv(this.struct), write)
  ensures allNodes(this.struct) == old(allNodes(this.struct))
   // here is the spec that is missing to complete the verification:
   // ensures forall p, q: Ref :: {p, q} subset allNodes(this.struct) ==>
   //            ( p.find() == q.find() <==>
   //              old(p.find() == q.find()) || old({p.find(), q.find()} subset {this.find(), other.find()})
   //            )
{
	var this1:Ref := find(this)
	var other1:Ref := find(other)
	if(other1 != this1)
	{
      assert this1 in allNodes(this.struct)
      
	  // lemma missing to complete the verification
	  //inhale acc(this1.struct, wildcard) && this1.struct == this.struct
      lemma0(this1, this)
	  
	  unfold acc(inv(this1.struct), write)
	  this1.parent := other1
	  
	  fold acc(inv(this1.struct), write)
	}
}*/

// class UnionFind
var nodes: Set[Ref]

predicate inv(this: Ref)
{
    acc(this.nodes, write) && !(null in this.nodes) &&
    (forall o : Ref :: o in (this.nodes) ==> acc(o.struct, wildcard)) &&
    (forall p : Ref :: p in (this.nodes) ==> p.struct == this)  &&
    (forall n : Ref :: n in (this.nodes) ==> acc(n.parent, write)) &&
    (forall q : Ref :: q in (this.nodes) ==> q.parent in this.nodes)
}

function allNodes(this:Ref): Set[Ref]
  requires acc(inv(this), wildcard)
{
    unfolding acc(inv(this), wildcard) in this.nodes
}


// add client