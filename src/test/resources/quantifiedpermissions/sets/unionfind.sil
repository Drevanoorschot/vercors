// class Node
var struct: Ref
var parent: Ref

/* add to structure */
method add(this: Ref, struct: Ref)
  requires acc(this.struct, write)
  requires acc(this.parent, write)
  requires acc(inv(struct), write)
  requires this.parent == null
  ensures acc(this.struct, wildcard)
  ensures this.struct == struct
  ensures acc(inv(this.struct), write)
  ensures valid(this)
  ensures allNodes(struct) == old(allNodes(struct)) union Set(this)
  ensures this == find(this)
  ensures (forall o: Ref :: o in old(allNodes(struct)) ==> (unfolding acc(inv(struct), wildcard) in find(o)) == old(unfolding acc(inv(struct), wildcard) in find(o)))
{
    this.struct := struct
    this.parent := this

    unfold acc(inv(struct), write)
    struct.nodes := (struct.nodes union Set(this))
    fold acc(inv(struct), write)
	
	//:: UnexpectedOutput(assert.failed:assertion.false, /silicon/issue/79/)
	assert unfolding acc(inv(struct), write) in this.parent == this
}

function valid(this:Ref) : Bool
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), wildcard)
{
  unfolding acc(inv(this.struct), wildcard) in (this in (this.struct.nodes))
}

function find(this:Ref) : Ref
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), wildcard)
  requires valid(this)
  ensures result != null
{
    (unfolding acc(inv(this.struct), wildcard) in (this == this.parent)) ? this : (unfolding acc(inv(this.struct), wildcard) in find(this.parent))
}

method unionn(this: Ref, other: Ref)
  requires acc(this.struct, wildcard)
  requires acc(inv(this.struct), write)
  requires valid(this)
  requires acc(other.struct, wildcard)
  requires (this.struct) == (other.struct)
  requires valid(other)
  ensures acc(this.struct, wildcard)
  ensures acc(inv(this.struct), write)
  ensures allNodes(this.struct) == old(allNodes(this.struct))
   // here is the spec that is missing to complete the verification:
   // ensures forall p, q: Ref :: {p, q} subset allNodes(this.struct) ==>
   //            ( p.find() == q.find() <==>
   //              old(p.find() == q.find()) || old({p.find(), q.find()} subset {this.find(), other.find()})
   //            )
{
	var this1:Ref := find(this)
	var other1:Ref := find(other)
	if(other1 != this1)
	{
/*	  This branch does not yet verify

      // lemma missing to complete the verification
	  inhale acc(this1.struct, wildcard) && this1.struct == this.struct && this1 in allNodes(this.struct)
	  
	  unfold acc(inv(this1.struct), write)
	  this1.parent := other1
	  
	  // verification fails here
	  fold acc(inv(this1.struct), write) */
	}
}

// class UnionFind
var nodes: Set[Ref]

predicate inv(this: Ref)
{
    acc(this.nodes, write) && !(null in this.nodes) &&
    (forall o : Ref :: o in (this.nodes) ==> acc(o.struct, wildcard)) &&
    (forall p : Ref :: p in (this.nodes) ==> p.struct == this)  &&
    (forall n : Ref :: n in (this.nodes) ==> acc(n.parent, write)) &&
    (forall q : Ref :: q in (this.nodes) ==> (q.parent != null) && (q.parent in (this.nodes)))
}

function allNodes(this:Ref): Set[Ref]
  requires acc(inv(this), wildcard)
{
    unfolding acc(inv(this), wildcard) in this.nodes
}