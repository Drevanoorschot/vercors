var v: Int
var n: Ref

predicate List(this: Ref) {
	acc(this.v, write) && acc(this.n, write) && (this.n != null ==> acc(this.n.List(), write))
}

function sum_rec(this: Ref): Int
	requires acc(this.List(), write)
{ unfolding acc(this.List(), write) in (this.v + (this.n == null ? 0 : sum_rec(this.n))) }

method sum_it(ys: Ref) returns (sum: Int)
  requires ys != null
	requires acc(ys.List(), write)
	ensures acc(ys.List(), write)
	ensures sum == old(sum_rec(ys))
{
  var xs: Ref
  xs := ys
  sum := 0

//  letass A := (xs != null) ==> (acc(xs.List(), write) && sum(xs) == OLD(sum(xs)))
//  letass B := acc(ys.List(), write) && sum(ys) == old(sum(ys))

  /* ghost */ var oldsum_xs: Int
              oldsum_xs := sum_rec(xs)

  package
    ((xs != null) ==> (acc(xs.List(), write) && sum_rec(xs) == oldsum_xs))
      --*
    (acc(ys.List(), write) && sum_rec(ys) == old(sum_rec(ys)))

  // TODO: There seems to be a problem with using old(sum_rec(ys)) here as well, even outside of wands.
  while (xs != null)
    invariant ((xs != null) ==> acc(xs.List(), write))
    invariant sum == (old(sum_rec(ys)) - (xs == null ? 0 : sum_rec(xs)));
    invariant
      ((xs != null) ==> (acc(xs.List(), write) && sum_rec(xs) == oldsum_xs))
        --*
      (acc(ys.List(), write) && sum_rec(ys) == old(sum_rec(ys)))
  {
    assume oldsum_xs == sum_rec(xs)
      /* [Malte] I think that it is crucial that oldsum_xs is assigned to at
       *         least once in the loop, because it will otherwise still have
       *         the value that it had outside of the loop (a Sil/Silicon feature).
       *         If so, then the assume in here is unsound because xs changes in
       *         every loop iteration.
       */

    /* ghost */ var prev_xs: Ref
                prev_xs := xs

    unfold acc(xs.List(), write)
    sum := sum + (xs.v)
    xs := xs.n;

  /* ghost */ var oldoldsum_xs: Int
              oldoldsum_xs := oldsum_xs

    if (xs != null) {
      oldsum_xs := sum_rec(xs)
    }

    package
      ((xs != null) ==> (acc(xs.List(), write) && sum_rec(xs) == oldsum_xs))
        --*
      folding acc(prev_xs.List(), write) in
        (applying
          (((prev_xs != null) ==> (acc(prev_xs.List(), write) && sum_rec(prev_xs) == oldoldsum_xs))
            --*
          (acc(ys.List(), write) && sum_rec(ys) == old(sum_rec(ys))))
        in
          (acc(ys.List(), write) && sum_rec(ys) == old(sum_rec(ys))));
  }

  apply
    ((xs != null) ==> (acc(xs.List(), write) && sum_rec(xs) == oldsum_xs))
      --*
    (acc(ys.List(), write) && sum_rec(ys) == old(sum_rec(ys)))
}
