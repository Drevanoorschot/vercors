var val: Int
var nxt: Ref

predicate Node(this: Ref) {
	   acc(this.val, write)
	&& acc(this.nxt, write)
	&& (this.nxt != null ==> acc(this.nxt.Node(), write))
}

function sum(this: Ref /* Node*/): Int
	requires acc(this.Node(), wildcard)
{
	unfolding acc(this.Node(), wildcard) in
		this.val + (this.nxt != null ? sum(this.nxt) : 0)
}

method loop1(y: Ref)
	requires y != null && acc(y.Node(), write)
{
	var s: Int := 0
	var x: Ref := y

	/* package ((x != null => x.Node()) --* y.Node)
				Should not package any permissions into the wand, because
				x and y are aliases.
	 */

	exhale /* INV */
			 (x != null ==> acc(x.Node(), write))
		&& (s == (old(sum(y)) - (x != null ? sum(x) : 0)))
 /* && ((x != null => x.Node()) --* y.Node) */

	while (x != null)
		/* INV:    (x != null ==> x.Node())
		 *      && (s == (old(sum(y)) - (x != null ? sum(x) : 0)))
		 *      && ((x != null => x.Node()) --* y.Node)
		 */
	{
		inhale /* INV */
				 (x != null ==> acc(x.Node(), write))
			&& (s == (old(sum(y)) - (x != null ? sum(x) : 0)))
	 /* && ((x != null => x.Node()) --* y.Node) */

		/* γ: x -> tx, y -> ty */
		/* h: ..., tx.Node() --* ty.Node) --- Let this chunk be M1 */

		unfold acc(x.Node(), write)

		/* h: ..., tx.Node() --* ty.Node), tx.nxt -> txn, tx.val -> tv */

		var oldx: Ref := x

		s := (s + (x.val))
		x := x.nxt

		/* γ: x -> tnx, y -> ty */

		/* package
				(x != null ==> x.Node())
					--*
				(folding oldit(x).Node in y.Node

			oldit(x) evaluates x in the state as it existed at the beginning
			of the current loop iteration.

			The hypothetical folding of oldit(x).Node requires chunks for
			oldit(x).val, oldit(x).nxt and oldit(x).nxt.Node. The latter
			is provided by the lhs of the magic wand, but the former two
			must be packaged into the wand.

			The folding gives a chunk tx.Node which can be used to apply
			the magic wand M1, yielding ty.Node, which is the expected
			rhs of the magic wand.
		*/
		exhale acc(oldx.val, write) && acc(oldx.nxt, write)
		/* inhale ((x != null ==> x.Node()) --* y.Node) */

		exhale /* INV */
				 (x != null ==> acc(x.Node(), write))
			&& (s == (old(sum(y)) - (x != null ? sum(x) : 0)))
	 /* && ((x != null => x.Node()) --* y.Node) */
	}

	inhale /* INV */
			 (x != null ==> acc(x.Node(), write))
		&& (s == (old(sum(y)) - (x != null ? sum(x) : 0)));
 /* && ((x != null => x.Node()) --* y.Node) */

  /* apply ((x != null => x.Node()) --* y.Node) */
  exhale true;
  inhale acc(y.Node(), write);

  assert s == old(sum(y))
}
