\documentclass{report}

\usepackage{todonotes}
\usepackage{enumitem}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{jmllistings}
\lstset{language=[jml]java,numbers=left,escapechar=\#}

\usepackage{tabularx}

\usepackage{vercors-macros}

\usepackage{float}
\usepackage{enumitem}
\floatstyle{plain}
\newfloat{listing}{tp}{lst}%%[section]
\floatname{listing}{\bf Listing}
%\newenvironment{listing}{\begin{figure}}{\end{figure}}
%\newenvironment{listing*}{\begin{figure*}}{\end{figure*}}
\newcommand{\listref}[1]{Lst.~\ref{#1}}
\newcommand{\Listref}[1]{Listing~\ref{#1}}

\author{Stefan Blom}
\title{Developers Guide to the VerCors Toolset}

\begin{document}

\maketitle

\tableofcontents

\chapter{Overview}

The VerCors tool is a compiler for specified programs. It works by 
parsing the inputs, applying many small program transformations,
then it can output the result and/or invoke an external verifier on them.
If a verifier is invoked then the error messages are translated back
and reported as the corresponding cause in the original program.

\input{structure.tex}

\chapter{Parsers}

The VerCors tool itself provides parsers for three languages:
PVL\footnote{Program Verification Language / Prototype Verification Language}, Java and C.
It uses the parser in the Viper library to be able to parse Silver.

The parsers for C and Java work in two passes. The first pass parses the executable code
and turn it into an AST with everything else stored as comments. The second pass
parses the comments and replaces them with specifications and ghost code ASTs.

The built-in parsers use ANTLR-v4 grammars. These grammars are designed
to keep the amount of duplication as small as possible. That is, we use
the import mechanism of ANTLR-v4 to be able to re-use
existing ANTLR-v4 grammars for Java and C. We also use a common specification
language grammar for all languages.

\par\noindent\begin{tabularx}{\textwidth}{lX}
grammar & description
\\
C.g4 & Imported grammar for C.
\\
Java.g4 & Imported grammar for Java.
\\
val.g4 & VerCors Annotation Language grammar.
\\
CML.g4 & Combine C and val to get specified C.
\\
JavaJML.g4 & Combine Java and val to get specified Java.
\\
PVFull.g4 & Define the specified language PVL around val.
\end{tabularx}

The existing grammars for Java and C are modified in the following ways:
\begin{itemize}
\item Comments are assigned to a channel in order to preserve them.
\item Line direction annotations, as generated by the C pre-processor are
assigned to a channel in order to compute the correct file positions of specifications.
\item The notion of identifier is modified. Both to allow val keywords to be used as identifiers
and to allow the use of \verb+\result+, etc.
\item The operators \verb+**+, \verb+==>+, and \verb+-*+ are inserted into the expression
syntax.
\item Several extra primary expression are added to the language.
\item Several extra primary types are added.
\item Additional statements are added.
\item Additional declarations are added.
\end{itemize}
The resulting grammars are used for both parsing the main file and for parsing
the comments containing the specifications.

The VerCors library uses its own intermediate language: Common Object Language (COL).
This is not a well-designed language, but rather a collection of AST nodes
that allows elegant representations of the various languages supported and
used by the tool: C, Java, PVL, JML, Silver, Chalice, Boogie, Dafny, etc.

The parse trees produced by the ANTLT-v4 parser are converted into COL
using visitors. Rather than handwriting all cases for every visitor
for every language variation, we use a layered class hierarchy.
The root is the \lstinline+ANTLRtoCOL+ class. This class takes care
of the elements of the common part of the specification language
and can be parameterized to take care of many expressions and
statements that are common in languages. It can do so because 
it is parameterized with a \lstinline+Syntax+ object, in which the 
syntax of the operators and built-in functions of COL can be found.
An optional middle layer consists of \lstinline+AbstractLanguageToCOL+ classes,
which implement the conversion of common parts of langauges.
The leafs contain the clauses for the actual language variant.
(Java, specified Java, etc.) To keep the amount of work needed to implement
these leaf classes minimal, the visitors are invoked using utility function that
will first call the visitor to allow the visitor to return the correct conversion,
but when the visitor returns null (which is the default implementation Eclipse generates
with one mouse click) a default conversion will be attempted.

\section{Specification Language}

The specification language contains block constructs, such as atomic blocks and action blocks.
Rather than allowing these blocks to begin and end in arbitrary locations, we haven chosen to
build upon the native block structure of the supported programming languages. Thus, the atomic
block
\begin{lstlisting}
action swap {
  int tmp = x;
  x = y;
  y = tmp; 
}
\end{lstlisting}
can be written in Java and C as
\begin{lstlisting}
{ //@ action swap ;
  int tmp = x;
  x = y;
  y = tmp; 
}
\end{lstlisting}

\chapter{Error Reporting}

The error reporting mechanism is built around the notion of an \emph{origin}.
Every transformation maintains the origin of every AST node that it produces.
This origin contains enough information to both trace back every AST node
to the source code from which it was generated and to convert error
messages with respect to the output to the correct message for the input.
E.g. an assertion failed in the output, might be reported as a
post-condition failure at a return statement.

\include{encoding_passes}

\chapter{Program Conversion by Rewriting of Expressions}

Simplifying logical formulas can transform them from a large subset to
a smaller subset that is compatible with the limitations of a given back-end
and/or improve the performance of a back-end by standardizing formulas.
To this end, a rewriter is under development that can read a rewrite system
from a file and apply this rewrite system to all (specification) expressions
in a program.

Roughly, the idea is that a rewrite system is represented as a ghost class,
in which:
\begin{itemize}
\item Fields in the class can be used as variables in the rules.
\item Binding constructs, such as the \lstinline+\forall+ are allowed.
\item The non-occurrence of a bound variable on the left-hand side of a rule
is written \lstinline+(e!i)+, where \lstinline+e+ has to be a field and
\lstinline+i+ has to be a bound variable.
\item Substitution on the right-hand side is written with \lstinline+\let+.
\end{itemize}

Currently, there are several bugs and limitations in the rewriter:
\begin{enumerate}
\item Types are not matched, so a rewrite rule meant for arrays get applied to sequences too,
which sometimes works, but often leads to errors.
\item The origins of the rewritten nodes are not set properly, so error messages are
reported at completely bogus locations.
\end{enumerate}

%\cleardoublepage
%\bibliographystyle{abbrv}
%\bibliography{extra}

\appendix

\input{keywords}

\end{document}

