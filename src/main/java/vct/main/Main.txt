package vct.main

import hre.config.ConfigurationNonStatic
import hre.lang.SystemNonStatic
import vct.main.options.CommandLineOptionsParser
import vct.main.passes.PassesGenerator

import java.io.File

object Main {
  def main(args: Array[String]): Unit = {
    val loggingSetup = new LoggingSetup
    val passesExecutioner = new PassesExecutioner
    val passesGenerator = new PassesGenerator
    val fileParser = new FileParser
    val optionsParser = new CommandLineOptionsParser
    val system = new SystemNonStatic
    val configuration = new ConfigurationNonStatic
    val program = new Program(loggingSetup,passesExecutioner,passesGenerator,fileParser,optionsParser,system,configuration)
    System.exit(program.run(args))
  }
<<<<<<< HEAD

  private def setupLogging(): Unit = {
    import hre.lang.System.LogLevel

    var level = logLevel.get match {
      case "silent" => LogLevel.Silent
      case "abort" => LogLevel.Abort
      case "result" => LogLevel.Result
      case "warning" => LogLevel.Warning
      case "info" => LogLevel.Info
      case "progress" => LogLevel.Progress
      case "debug" => LogLevel.Debug
      case "all" => LogLevel.All
    }

    if (!debugFilters.get.isEmpty && level.getOrder < hre.lang.System.LogLevel.Debug.getOrder)
      level = hre.lang.System.LogLevel.Debug

    for (filter <- debugFilters.get.asScala.keys) {
      if (filter.contains(":") /* With line number */ ) hre.lang.System.addDebugFilterByLine(filter)
      else hre.lang.System.addDebugFilterByClassName(filter)
    }

    hre.lang.System.setOutputStream(System.out, level)
    hre.lang.System.setErrorStream(System.err, level)
    System.setErr(new ForbiddenPrintStream(System.err))
    System.setOut(new ForbiddenPrintStream(System.out))
  }

  private def checkOptions(): Unit = {
    if (version.get) {
      Output("%s %s", BuildInfo.name, BuildInfo.version)
      Output("Built by sbt %s, scala %s at %s", BuildInfo.sbtVersion, BuildInfo.scalaVersion, Instant.ofEpochMilli(BuildInfo.builtAtMillis))
      if (BuildInfo.currentBranch != "master")
        Output("On branch %s, commit %s, %s",
          BuildInfo.currentBranch, BuildInfo.currentShortCommit, BuildInfo.gitHasChanges)

      throw new HREExitException(0)
    }

    if (help_passes.get) {
      Output("The following passes are available:")
      Passes.BY_KEY.foreach {
        case (key, pass) => Output(" %-12s : %s", key, pass.description)
      }
      throw new HREExitException(0)
    }

    if(Seq(
      CommandLineTesting.enabled,
      silver.used,
      pass_list.asScala.nonEmpty,
      Configuration.veymont_file.used()
    ).forall(!_)) {
      Fail("no back-end or passes specified")
    }

    if (stopBeforeBackend.get() && stopAfterTypecheck.get()) {
      Fail("The --stop-before-backend and --stop-after-typecheck flags are mutually exclusive.")
    }

    if (silver.used) silver.get match {
      case "silicon" => // Nothing to check for
      case "carbon" => // Nothing to check for
      case _ =>
        Fail("unknown silver backend: %s", silver.get)
    }

    val vFile = Configuration.veymont_file.get()
    if(vFile != null) {
      val nonPVL = inputPaths.filter(!_.endsWith(".pvl"))
      if(nonPVL.nonEmpty)
        Fail("VeyMont cannot use non-PVL files %s",nonPVL.mkString(", "))
      if(!vFile.endsWith(".pvl"))
        Fail("VeyMont cannot output to non-PVL file %s",vFile)
    }
  }

  private def parseInputs(inputPaths: Array[String]): Unit = {
    Progress("parsing inputs...")
    report = new PassReport(new ProgramUnit)
    report.setOutput(report.getInput)
    report.add(new ErrorDisplayVisitor)

    tk.show
    for (pathName <- inputPaths) {
      val path = Paths.get(pathName)
      if (!no_context.get) FileOrigin.add(path, gui_context.get)
//      report.getOutput.add(Parsers.parseFile(path))
    }

    Progress("Parsed %d file(s) in: %dms", Int.box(inputPaths.length), Long.box(tk.show))

  }


  private def collectPassesForVeyMont : Seq[AbstractPass] = Seq(
    BY_KEY("VeyMontStructCheck"),
    BY_KEY("VeyMontTerminationCheck"),
  //  BY_KEY("VeyMontGlobalLTS"),
    BY_KEY("VeyMontDecompose"),
    BY_KEY("VeyMontLocalLTS"),
    BY_KEY("removeTaus"),
    BY_KEY("removeEmptyBlocks"),
    BY_KEY("VeyMontBarrier"),
    BY_KEY("VeyMontLocalProgConstr"),
    BY_KEY("VeyMontAddChannelPerms"),
    BY_KEY("VeyMontAddStartThreads"),
    BY_KEY("printPVL"),
  )

  object ChainPart {
    def inflate(parts: Seq[ChainPart]): Seq[Seq[String]] =
      parts.headOption match {
        case None => Seq(Seq())
        case Some(pass: Do) => inflate(parts.tail).map(pass.key +: _)
        case Some(Choose(alts@_* /* collect varargs into alts */)) =>
          val tail = inflate(parts.tail)
          alts.map(inflate).flatMap(branch => branch.flatMap(choice => tail.map(choice ++ _)))
      }
  }
  sealed trait ChainPart
  implicit sealed class Do(val key: String) extends ChainPart
  case class Choose(choices: Seq[ChainPart]*) extends ChainPart

  val silverPassOrder: Seq[ChainPart] = Seq(
    "removeIgnoredElements",
    "splitCompositeDeclarations",
    "resolveTypeExpressions",
    "loadExternalClasses",
    "stringClassToPrimitive",
    "standardize",
    "interpretMethodAnnotations",
    "wrapTopLevelDeclarations",
    "removeUnusedExternMethods",
    "encodeLockInvariantProof",
    "synchronizedToTryFinally",
    "encodeForkLockWait",
    "specifyImplicitLoopLabels",
    "switchToIfChain",
    "addDefaultConstructor",
    "propagateAbstractMethodContracts",
    "arrayNullValuesToNone",
    "finalizeArguments",
    "actionHeaderToActionBlock",
    "addRequirementSatCheck",
    "pureMethodsToFunctions",
    "sortWithThen",
    Choose(
      Seq(),
      Seq("dereferenceToFieldAccess", "checkHistory"),
      Seq("dereferenceToFieldAccess", "checkAxioms"),
      Seq("dereferenceToFieldAccess", "checkDefined"),
    ),
    "desugarADTOperators",
    "inlineAssignmentToStatement",
    "continueToBreak",
    Choose(
      Seq("breakReturnToExceptions"),
      Seq("breakReturnToGoto"),
    ),
    "encodeCurrentThread",
    "collectStaticFields",
    "inferADTElementTypes",
    "encodeKernelClass",
    "checkAssignInPar",
    "encodeMagicWands",
    "inline",
    "inlineAtomicMethods",
    "openMPToParallelBlocks",
    "propagateInvariants",
    "dummy-InvariantsPropagatedHere",
    "compileToJava",
    "liftGhostCode",
    "inlineWithThenHints",
    "inlineParallelAtomics",
    "encodeParallelBlocks",
    Choose(
      Seq("stackLocationsToHeapLocations", "pointersToArraysLifted"),
      Seq("pointersToArrays"),
    ),
    "desugarValidPointer",
    "simplify",
    "simplifySums",
    "optimizeForSilver",
    "encodeVectorBlocks",
    "adtOperatorsToFunctions",
    "introExcVar",
    "desugarArrayOps",
    "flattenNestedExpressions",
    "encodeInheritanceToDomain",
    "tryThrowSignalsToGoto",
    "importADTsAndRefEncode",
    "returnTypeToOutParameter",
    "reduceQuantifierNesting",
    "inlinePatternsToTriggers",
    "generateQuantifierTriggers",
    "scaleAllPredicateApplications",
    "collectInnerDeclarations",
    "collectDeclarations",
  )

  def validChain(chain: Seq[AbstractPass], featuresIn: Set[Feature]): Boolean = {
    var features = featuresIn

    for(pass <- chain) {
      if((features -- pass.permits).nonEmpty) {
        Debug(s"Rejecting because ${pass.key} does not allow ${features -- pass.permits}")
        return false
      }

      features ++= pass.introduces
      features --= pass.removes
    }

    true
  }

  def minimize(chain: Seq[AbstractPass], featuresIn: Set[Feature]): Seq[AbstractPass] = {
    for(toRemove <- 0 until chain.size-1) {
      val newChain = chain.take(toRemove) ++ chain.drop(toRemove + 1)
      if(validChain(newChain, featuresIn)) {
        return minimize(newChain, featuresIn)
      }
    }
    chain
  }

  def filterNopPasses(chain: Seq[AbstractPass], featuresIn: Set[Feature]): Seq[AbstractPass] = {
    var features = featuresIn

    for(toRemove <- 0 until chain.size-1) {
      if(chain(toRemove).removes.intersect(features).isEmpty) {
        val newChain = chain.take(toRemove) ++ chain.drop(toRemove + 1)
        return filterNopPasses(newChain, featuresIn)
      }

      features ++= chain(toRemove).introduces
      features --= chain(toRemove).removes
    }

    chain
  }

  def computeGoal(featuresIn: Set[Feature]): Option[Seq[AbstractPass]] = {
    val toolPass = silver.get() match {
      case "carbon" => BY_KEY("applyCarbon")
      case "silicon" => BY_KEY("applySilicon")
    }

    // Expand all choices
    val chains = ChainPart.inflate(silverPassOrder).map(_.map(BY_KEY(_)) :+ toolPass)

    // Filter out passes that don't remove anything (even before the chain is valid)
    val filteredChains = chains.map(filterNopPasses(_, featuresIn))

    // Filter for valid chains
    val validChains = filteredChains.filter(validChain(_, featuresIn))

    // Remove any passes that when removed constitute a valid chain
    val minimalChains = validChains.map(minimize(_, featuresIn))
    if(minimalChains.nonEmpty) {
      Some(minimalChains.minBy(_.size))
    } else {
      None
    }
  }

  def collectPassesForSilver: Seq[AbstractPass] = {
    report = Passes.BY_KEY("checkTypesJava").apply_pass(report, Array())

    var features = Feature.scan(report.getOutput) ++ Set(
      // These are "gated" features: they are (too) hard to detect normally.
      vct.col.features.NotFlattened,
      vct.col.features.BeforeSilverDomains,
      vct.col.features.NullAsOptionValue,
      vct.col.features.NotOptimized,
      vct.col.features.DeclarationsNotLifted,
      vct.col.features.ParallelLocalAssignmentNotChecked,
      vct.col.features.NotJavaResolved,
      vct.col.features.InvariantsPropagatedHere,
    ) ++ Set(
      // These are normal features, but need to run always for some reason
      vct.col.features.ScatteredDeclarations, // this pass finds duplicate names (even if they're not scattered)
      vct.col.features.ImplicitLabels, // Can be detected, lazy, sorry
    )

    if(features.contains(vct.col.features.Extern))
      /* too hard to detect whether an extern decl is used, but it needs top-level-decls and we don't want to run that
       * for the silver frontend. */
      features += vct.col.features.UnusedExtern

    // options are encoded as gated features
    if(sat_check.get()) features += vct.col.features.NeedsSatCheck
    if(check_axioms.get()) features += vct.col.features.NeedsAxiomCheck
    if(check_defined.get()) features += vct.col.features.NeedsDefinedCheck
    if(check_history.get()) features += vct.col.features.NeedsHistoryCheck

    val passes = if (stopAfterTypecheck.get()) {
      Seq()
    } else {
      computeGoal(features).get
    }

    if (stopBeforeBackend.get()) {
      // We drop the last pass, which happens to be the silicon/carbon pass
      passes.init
    } else {
      passes
    }
  }

  private def getPasses: Seq[AbstractPass] = {
    if (pass_list_option.used) {
      pass_list.asScala.map(key => BY_KEY.get(key) match {
        case None => Fail("Unknown pass: %s", key); ???
        case Some(pass) => pass
      }).toSeq
    }
    else if (silver.used) collectPassesForSilver
    else if (Configuration.veymont_file.used()) collectPassesForVeyMont
    else { Fail("no back-end or passes specified"); ??? }
  }

  private def show(pass: AbstractPass): Unit = {
    val name = show_file.get
    if (name != null) {
      val file = String.format(name, pass.key)
      val out = new PrintWriter(new FileOutputStream(file))
      vct.col.ast.util.Configuration.getDiagSyntax.print(out, report.getOutput)
      out.close()
    }
    else {
      val out = hre.lang.System.getLogLevelOutputWriter(hre.lang.System.LogLevel.Info)
      vct.col.ast.util.Configuration.getDiagSyntax.print(out, report.getOutput)
      out.close()
    }
  }

  private def doPasses(passes: Seq[AbstractPass]): Unit = {
    for((pass, i) <- passes.zipWithIndex) {
      if (debugBefore.has(pass.key)) report.getOutput.dump()
      if (show_before.contains(pass.key)) show(pass)

      val featuresIn = if(strictInternalConditions.get()) {
        Feature.scan(report.getInput)
      } else { Set.empty }

      tk.show
      report = pass.apply_pass(report, Array())

      if(report.getFatal > 0) {
        Verdict("The final verdict is Fail")
        return
      }

      Progress("[%02d%%] %s took %d ms", Int.box(100 * (i+1) / passes.size), pass.key, Long.box(tk.show))

      if (debugAfter.has(pass.key)) report.getOutput.dump()
      if (show_after.contains(pass.key)) show(pass)
      if (stopAfter.contains(pass.key)) Fail("exit after pass %s", pass)

      report = BY_KEY("checkTypesJava").apply_pass(report, Array())

      if(report.getFatal > 0) {
        Verdict("The final verdict is Fail")
        return
      }

      if(strictInternalConditions.get()) {
        val scanner = new RainbowVisitor(report.getOutput)
        scanner.source().accept(scanner)
        val featuresOut = scanner.features.toSet

        val notRemoved = featuresOut.intersect(pass.removes)
        val extraIntro = (featuresOut -- featuresIn) -- pass.introduces

        val permissiveFeatures = Set(
          vct.col.features.QuantifierWithoutTriggers,
          vct.col.features.NestedQuantifiers,
          vct.col.features.ExceptionalReturn,
          vct.col.features.ContextEverywhere,
        )

        if (notRemoved.nonEmpty) {
          notRemoved.foreach(feature => {
            Output("Pass %s did not remove %s:", pass, feature)
            scanner.logBlameExamples(feature)
          })
        }

        if (extraIntro.nonEmpty) {
          extraIntro.foreach(feature => {
            Output("Pass %s introduced %s", pass, feature)
            scanner.logBlameExamples(feature)
          })
        }

        if((notRemoved -- permissiveFeatures).nonEmpty || (extraIntro -- permissiveFeatures).nonEmpty) {
          Abort("Halting, because strict internal conditions are enabled.")
        }
      }

    }

    Verdict("The final verdict is Pass")
  }

  private def run(args: Array[String]): Int = {
    var exit = 0
    val wallStart = System.currentTimeMillis
    tk = new TimeKeeper
    try {
      hre.lang.System.setOutputStream(System.out, hre.lang.System.LogLevel.Info)
      hre.lang.System.setErrorStream(System.err, hre.lang.System.LogLevel.Info)
      inputPaths = parseOptions(args)
      setupLogging()
      checkOptions()
      if (CommandLineTesting.enabled) CommandLineTesting.runTests()
      else {
        parseInputs(inputPaths)
        doPasses(getPasses)
      }
    } catch {
      case e: HREExitException =>
        exit = e.exit
        if(exit != 0)
          Verdict("The final verdict is Error")
      case e: Throwable =>
        DebugException(e)
        Warning("An unexpected error occured in VerCors! "
              + "Please report an issue at https://github.com/utwente-fmt/vercors/issues/new. "
              + "You can see the full exception by adding '--debug vct.main.Main' to the flags.")
        Verdict("The final verdict is Error")
    } finally {
      Progress("entire run took %d ms", Long.box(System.currentTimeMillis - wallStart))
      if(notifySetting.get()) {
        Notifier.notify("VerCors", "Verification is complete")
      }
    }
    exit
  }
}
=======
}
>>>>>>> issue-678-scalatest
