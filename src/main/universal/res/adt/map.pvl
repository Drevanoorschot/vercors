adt map<K, V> {
  pure map<K, V> map_empty();
  pure map<K, V> map_cons(K k, V v, map<K, V> tail);

  pure set<K> map_keys(map<K, V> m);

  pure K map_cons_inv_k(map<K, V> m);
  pure V map_cons_inv_v(map<K, V> m);
  pure map<K, V> map_cons_inv_tail(map<K, V> m);

  axiom
    (\forall K k; true; (\forall V v; true; (\forall map<K, V> m;
      map_empty() != {:map_cons(k, v, m):})));

  axiom map_keys(map_empty()) == set<K>{};

  axiom
    (\forall K k; true; (\forall V v; true; (\forall map<K, V> tail;
      {:map_keys(map_cons(k, v, tail)):} == set<K>{k} + map_keys(tail)
    )));

  axiom
    (\forall K k; true; (\forall V v; true; (\forall map<K, V> tail;
      {:map_cons_inv_k(map_cons(k, v, tail)):} == k)));

  axiom
    (\forall K k; true; (\forall V v; true; (\forall map<K, V> tail;
      {:map_cons_inv_v(map_cons(k, v, tail)):} == v)));

  axiom
    (\forall K k; true; (\forall V v; true; (\forall map<K, V> tail;
      {:map_cons_inv_tail(map_cons(k, v, tail)):} == tail)));
}

ensures \result >= 0;
ensures (\result == 0) == (m == map_empty());
ensures (\result == 0) == (\forall K k; k \in map_keys(m); false);
ensures (\result == 0) == (\forall V v; v \in map_values(m); false);
ensures (\result == 0) == (\forall tuple<K, V> t; t \in map_items(m); false);
pure int map_size(map<K, V> m) = |map_keys(m)|;

requires m != map_empty();
pure K <K, V>map_cons_get_k(map<K, V> m) = map_cons_inv_k(m);

requires m != map_empty();
pure V <K, V>map_cons_get_v(map<K, V> m) = map_cons_inv_v(m);

requires m != map_empty();
pure map<K, V> <K, V>map_cons_get_tail(map<K, V> m) = map_cons_inv_tail(m);

requires k \in map_keys(m);
pure V <K, V>map_get(map<K, V> m, K k) =
  map_cons_get_k(m) == k ? map_cons_get_v(m) : map_get(map_cons_get_tail(m), k);

ensures |\result| <= map_size(m);
ensures (\forall V v; true; {:v \in \result:} == (\exists K k; k \in map_keys(m); map_get(m, k) == v));
pure set<V> <K, V>map_values(map<K, V> m) =
  m == map_empty() ? set<V>{} : set<V>{map_cons_get_v(m)} + map_values(map_cons_get_tail(m));

ensures |\result| = map_size(m);
ensures (
  \forall tuple<K, V> t; true;
    (t \in \result) == (t.fst \in map_keys(m) && map_get(m, t.fst) == t.snd)
);
pure set<tuple<K, V>> <K, V>map_items(map<K, V> m) =
  m == map_empty() ? set<tuple<K, V>>{} :
    set<tuple<K, V>>{tuple<K, V>{map_cons_get_k(m), map_cons_get_v(m)}} +
      map_items(map_cons_get_tail(m));

ensures \result ==> map_size(left) == map_size(right);
pure boolean <K, V>map_equals(map<K, V> left, map<K, V> right) =
  map_keys(left) == map_keys(right) && (
    \forall K k; k \in map_keys(left); map_get(left, k) == map_get(right, k)
  );

pure boolean <K, V>map_disjoint(map<K, V> left, map<K, V> right) =
  (\forall K k; true; !(k \in map_keys(left)) || !(k \in map_keys(right)));

ensures !(k \in map_keys(m)) ==> map_equals(\result, m);
ensures !(k \in map_keys(\result));
ensures (\forall K l; k != l; l \in map_keys(m) == l \in map_keys(\result));
ensures (\forall K l; l \in map_keys(\result) && k != l; map_get(\result, l) == map_get(m, l));
ensures k \in map_keys(m) ==> map_size(m) == map_size(\result) + 1;
pure map<K, V> <K, V>map_remove(map<K, V> m, K k) =
  m == map_empty() ? map_empty() :
    map_cons_get_k(m) == k ? map_remove(map_cons_get_tail(m), k) :
      map_cons(map_cons_get_k(m), map_cons_get_v(m), map_remove(map_cons_get_tail(m), k));