package semper
package silicon
package debugging

import com.weiglewilczek.slf4s.Logging
import scala.collection.mutable.HashMap
import silicon.interfaces.{VerificationResult, Success, Producer, Consumer, Executor, Evaluator}
import silicon.interfaces.decider.Decider
import silicon.interfaces.state.{Store, Heap, PathConditions, State, StateFactory, StateFormatter, HeapMerger}
//import silicon.ast.{ASTNode, TopLevelDecl, Class, Member, FieldMember, Method, Function,
//    Predicate, Expression, MonitorInvariant, LockChangeExpr, And, Channel,
//    DebtFreeExpr, ChannelClass}
import silicon.reporting.{DefaultContext, Bookkeeper}
import silicon.interfaces.reporting.History
import silicon.interfaces.reporting.ContextFactory
import silicon.interfaces.state.StateFactory
import silicon.state.TypeConverter
import silicon.state.terms.{PermissionsTuple, FractionalPermissions}
import silicon.reporting.{DefaultContextFactory, DefaultTraceView, DefaultTraceViewFactory}
import silicon.interfaces.reporting.TraceView
import silicon.interfaces.reporting.Context
import silicon.interfaces.reporting.TraceViewFactory

/** Factory for DebuggingVerifier */
class DebuggingVerifierFactory[ST <: Store[ST], H <: Heap[H], PC <: PathConditions[PC], S <: State[ST, H, S], TV <: TraceView[TV, ST, H, S]] 
extends VerifierFactory[DebuggingVerifier[ST, H, PC, S, TV], TV, ST, H, PC, S] {
  
  def create(config: Config,
      decider: Decider[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
      stateFactory: StateFactory[ST, H, S],
      typeConverter: TypeConverter,
//      lockSupport: LockSupport[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
//      creditSupport: CreditSupport[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
//      immutabilitySupport: ImmutabilitySupport[ST, H, PC, S, DefaultContext[ST, H, S], TV],
      chunkFinder: ChunkFinder[ST, H, S, DefaultContext[ST, H, S], TV],
      stateFormatter: StateFormatter[ST, H, S, String],
      heapMerger: HeapMerger[H],
      stateUtils: StateUtils[ST, H, PC, S, DefaultContext[ST, H, S]],
      bookkeeper: Bookkeeper,
      traceviewFactory: TraceViewFactory[TV, ST, H, S]) = 
        
        new DebuggingVerifier[ST, H, PC, S, TV](config, decider,
                       stateFactory, typeConverter,
                       /*lockSupport, creditSupport, immutabilitySupport,*/ chunkFinder,
                       stateFormatter, heapMerger, stateUtils, bookkeeper, traceviewFactory)
  
}

/** Alternative implementation of AbstractVerifier that collects all recorded histories */
class DebuggingVerifier[ST <: Store[ST], H <: Heap[H], PC <: PathConditions[PC],
                      S <: State[ST, H, S],
                      TV <: TraceView[TV, ST, H, S]]
    ( val config: Config,
      val decider: Decider[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
      val stateFactory: StateFactory[ST, H, S],
      val typeConverter: TypeConverter,
//      val lockSupport: LockSupport[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
//      val creditSupport: CreditSupport[PermissionsTuple, ST, H, PC, S, DefaultContext[ST, H, S]],
//      val immutabilitySupport: ImmutabilitySupport[ST, H, PC, S, DefaultContext[ST, H, S], TV],
      val chunkFinder: ChunkFinder[ST, H, S, DefaultContext[ST, H, S], TV],
      val stateFormatter: StateFormatter[ST, H, S, String],
      val heapMerger: HeapMerger[H],
      val stateUtils: StateUtils[ST, H, PC, S, DefaultContext[ST, H, S]],
      val bookkeeper: Bookkeeper,
      val traceviewFactory: TraceViewFactory[TV, ST, H, S])
    extends AbstractVerifier[ST, H, PC, S, TV]
      with Logging 
{
  
  val contextFactory = new DefaultContextFactory[ST, H, S]
  
  val ev = new DefaultElementVerifier(config, decider,
                                     stateFactory, typeConverter,
                                     /*lockSupport, creditSupport, immutabilitySupport,*/ chunkFinder,
                                     stateFormatter, heapMerger, stateUtils, bookkeeper, contextFactory, traceviewFactory)
  
  
  /** Collection of histories of all verified elements */
  val histories: HashMap[String, History[ST, H, S]] = HashMap()
  
  override def verifyMember(member: Member) = {
    val v = ev.verify(member)
    v._2.results = v._1 :: v._1.allPrevious
    
    histories += member.fullName -> v._2
    
    v._1
  }
  
  override def verifyChannel(ch: Channel) = {
    val v = ev.verify(ch)
    v._2.results = v._1 :: v._1.allPrevious
    
    histories += ch.fullName -> v._2
    
    v._1
  }

}
