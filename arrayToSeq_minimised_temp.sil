domain VCTArray[CT] {
  
  function loc(a: VCTArray[CT], i: Int): CT
  
  function alen(a: VCTArray[CT]): Int
  
  axiom len_nonneg {
    (forall a: VCTArray[CT] :: { alen(a) } alen(a) >= 0)
  }
}

//  a field 
field item: Int

function arrayToSeqHelper(xs: VCTArray[Ref], i: Int): Seq[Int]
  requires 0 <= i && i <= alen(xs)
  requires (forall j: Int :: 0 <= j && j < alen(xs) ==> acc(loc(xs, j).item, wildcard))

  ensures |result| == alen(xs) - i
  ensures (forall j: Int :: i <= j && j < alen(xs) ==> result[j - i] == loc(xs, j).item)
{
  (i < alen(xs) ? Seq(loc(xs, i).item) ++ arrayToSeqHelper(xs, i + 1) : Seq[Int]())
}

method method_arrayToSeqHelper(xs: VCTArray[Ref], i: Int) returns (res: Seq[Int])
  requires 0 <= i && i <= alen(xs)
  requires (forall j: Int :: 0 <= j && j < alen(xs) ==> acc(loc(xs, j).item, wildcard))

  ensures 0 <= i && i <= alen(xs)
  ensures (forall j: Int :: 0 <= j && j < alen(xs) ==> acc(loc(xs, j).item, wildcard))

  ensures |res| == alen(xs) - i
  ensures (forall j: Int :: i <= j && j < alen(xs) ==> res[j - i] == loc(xs, j).item)
{
  if (i < alen(xs)) {
    var tail: Seq[Int]
    tail := method_arrayToSeqHelper(xs, i + 1)
    res := Seq(loc(xs, i).item) ++ tail
  } else {
    res := Seq()
  }
}
