domain frac {
  
  function frac_val(a: frac): Perm
  
  axiom frac_eq {
    (forall a: frac, b: frac :: { frac_val(a),frac_val(b) } (frac_val(a) == frac_val(b)) == (a == b))
  }
  
  axiom frac_bound {
    (forall a: frac :: 0 / 1 < frac_val(a) && frac_val(a) <= 1 / 1)
  }
}

domain VCTArray[CT] {
  
  function loc(a: VCTArray[CT], i: Int): CT
  
  function alen(a: VCTArray[CT]): Int
  
  axiom len_nonneg {
    (forall a: VCTArray[CT] :: { alen(a) } alen(a) >= 0)
  }
}

domain VCTOption[T] {
  
  function VCTNone(): VCTOption[T]
  
  function VCTSome(t: T): VCTOption[T]
  
  function getVCTOption(o: VCTOption[T]): T
  
  axiom not_equal_vct {
    (forall x: T :: VCTNone() != VCTSome(x))
  }
  
  axiom get_axiom_vct {
    (forall x: T :: getVCTOption(VCTSome(x)) == x)
  }
  
  axiom get_axiom_vct_2 {
    (forall x: VCTOption[T] :: VCTSome(getVCTOption(x)) == x)
  }
}

//  a field 
field item: Int

function arrayToSeqHelper(diz: Ref, xs: VCTOption[VCTArray[Ref]], i: Int): Seq[Int]
  requires diz != null
  requires xs != VCTNone()
  requires 0 <= i && i <= alen(getVCTOption1(xs))
  requires (forall j: Int :: 0 <= j && j < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), j).item, wildcard))
  ensures |result| == alen(getVCTOption1(xs)) - i
  ensures i < alen(getVCTOption1(xs)) ==> result[0] == loc(getVCTOption1(xs), i).item;
  ensures i == alen(getVCTOption1(xs)) ==> (forall j: Int :: i <= j && j < alen(getVCTOption1(xs)) ==> result[j - i] == loc(getVCTOption1(xs), j).item)
  ensures (forall j: Int :: i <= j && j < alen(getVCTOption1(xs)) ==> result[j - i] == loc(getVCTOption1(xs), j).item)
{
  (i < alen(getVCTOption1(xs)) ? Seq(loc(getVCTOption1(xs), i).item) ++ arrayToSeqHelper(diz, xs, i + 1) : Seq[Int]())
}

method method_arrayToSeqHelper(diz: Ref, xs: VCTOption[VCTArray[Ref]], i: Int) returns (res: Seq[Int])
  requires diz != null
  requires xs != VCTNone()
  requires 0 <= i && i <= alen(getVCTOption1(xs))
  requires (forall j: Int :: 0 <= j && j < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), j).item, wildcard))

  ensures diz != null
  ensures xs != VCTNone()
  ensures 0 <= i && i <= alen(getVCTOption1(xs))
  ensures (forall j: Int :: 0 <= j && j < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), j).item, wildcard))

  ensures |res| == alen(getVCTOption1(xs)) - i
  ensures (forall j: Int :: i <= j && j < alen(getVCTOption1(xs)) ==> res[j - i] == loc(getVCTOption1(xs), j).item)
{
  if (i < alen(getVCTOption1(xs))) {
    var tail: Seq[Int]
    tail := method_arrayToSeqHelper(diz, xs, i + 1)
    res := Seq(loc(getVCTOption1(xs), i).item) ++ tail
  } else {
    res := Seq()
  }
}

function arrayToSeq(diz: Ref, xs: VCTOption[VCTArray[Ref]]): Seq[Int]
  requires diz != null
  requires xs != VCTNone()
  requires (forall i: Int :: 0 <= i && i < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), i).item, wildcard))
  ensures |result| == alen(getVCTOption1(xs))
  ensures (forall i: Int :: 0 <= i && i < alen(getVCTOption1(xs)) ==> result[i] == loc(getVCTOption1(xs), i).item)
{
  arrayToSeqHelper(diz, xs, 0)
}

function sumSeq(diz: Ref, xs: Seq[Int]): Int
  requires diz != null
{
  (0 < |xs| ? xs[0] + sumSeq(diz, xs[1..]) : 0)
}

function new_frac(x: Perm): frac
  requires 0 / 1 < x && x <= 1 / 1
  ensures frac_val(result) == x

function getVCTOption1(x: VCTOption[VCTArray[Ref]]): VCTArray[Ref]
  requires x != VCTNone()
{
  getVCTOption(x)
}

method lemma_sum_update(diz: Ref, xs: VCTOption[VCTArray[Ref]], ys: VCTOption[VCTArray[Ref]], oldTotal: Int, i: Int, P: frac)
  requires diz != null
  requires none < frac_val(P) && frac_val(P) < write 
  requires xs != VCTNone()
  requires (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), i_fresh_rw_0).item, frac_val(P)))
  requires ys != VCTNone()
  requires (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(ys)) ==> acc(loc(getVCTOption1(ys), i_fresh_rw_0).item, frac_val(P)))
  requires alen(getVCTOption1(xs)) == alen(getVCTOption1(ys))
  requires 0 <= i && i < alen(getVCTOption1(xs))
  requires (forall j: Int :: 0 <= j && j < alen(getVCTOption1(xs)) && j != i ==> loc(getVCTOption1(xs), j).item == loc(getVCTOption1(ys), j).item)
  requires sumSeq(diz, arrayToSeq(diz, xs)) == oldTotal
{
  var f_1: Ref
  var f_2: Ref
  var f_3: VCTArray[Ref]
  var f_4: VCTArray[Ref]
  var f_5: Perm
  var f_6: frac
  f_3 := getVCTOption1(xs)
  f_1 := loc(f_3, i)
  f_4 := getVCTOption1(ys)
  f_2 := loc(f_4, i)
  f_5 := frac_val(P)
  f_6 := new_frac(f_5 / 2)
  lemma_sum_update_before(diz, xs, ys, 0, oldTotal, i, f_1.item, f_2.item, f_6)
  // assert
  assert sumSeq(diz, arrayToSeqHelper(diz, ys, 0)) == oldTotal - loc(getVCTOption1(xs), i).item + loc(getVCTOption1(ys), i).item
}

method lemma_sum_update_before(diz: Ref, xs: VCTOption[VCTArray[Ref]], ys: VCTOption[VCTArray[Ref]], b: Int, oldTotal: Int, i: Int, oldVal: Int, newVal: Int, P: frac)
  requires diz != null
  requires none < frac_val(P) && frac_val(P) < write
  requires xs != VCTNone()
  requires ys != VCTNone()
  requires (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), i_fresh_rw_0).item, frac_val(P)))
  requires (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(ys)) ==> acc(loc(getVCTOption1(ys), i_fresh_rw_0).item, frac_val(P)))
  requires alen(getVCTOption1(xs)) == alen(getVCTOption1(ys))
  requires 0 <= b && b <= alen(getVCTOption1(xs))
  requires 0 <= i && i < alen(getVCTOption1(xs))
  requires b <= i
  requires (forall j: Int :: 0 <= j && j < alen(getVCTOption1(xs)) && j != i ==> loc(getVCTOption1(xs), j).item == loc(getVCTOption1(ys), j).item)
  requires loc(getVCTOption1(xs), i).item == oldVal
  requires loc(getVCTOption1(ys), i).item == newVal
  requires sumSeq(diz, arrayToSeqHelper(diz, xs, b)) == oldTotal
  ensures (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(xs)) ==> acc(loc(getVCTOption1(xs), i_fresh_rw_0).item, frac_val(P)))
  ensures (forall i_fresh_rw_0: Int :: 0 <= i_fresh_rw_0 && i_fresh_rw_0 < alen(getVCTOption1(ys)) ==> acc(loc(getVCTOption1(ys), i_fresh_rw_0).item, frac_val(P)))
  ensures sumSeq(diz, arrayToSeqHelper(diz, ys, b)) == oldTotal - oldVal + newVal
